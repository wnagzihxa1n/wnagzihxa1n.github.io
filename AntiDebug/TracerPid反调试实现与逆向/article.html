<!DOCTYPE html>
<html>
<head>
<title>TracerPid反调试实现与逆向</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="tracerpid-">TracerPid反调试实现与逆向</h1>
<p><strong>Author：wnagzihxain<br>Mail：tudouboom@163.com</strong></p>
<p>经常会在一些脱壳文章里面看到<code>TracerPid</code>，<code>ptrace</code>什么的，那这些都是什么意思呢？</p>
<p>我们来查看本程序的<code>/proc/{PID}/status</code>文件</p>
<pre><code>C:\Users\wangz&gt;adb shell
root@jflte:/ # ps |grep &quot;wnagzihxain&quot;
u0_a123   29139 281   960944 31468 ffffffff 4005a8e0 S com.wnagzihxain.myapplication
root@jflte:/ # cat /proc/29139/status
Name:   n.myapplication /*进程的程序名*/
State:  S (sleeping)
Tgid:   29139 /*线程组号*/
Pid:    29139 /*进程pid process id*/
PPid:   281 /*父进程的pid parent processid*/
TracerPid:      0 /*跟踪进程的pid*/
Uid:    10123   10123   10123   10123 /*uid euid suid fsuid*/
Gid:    10123   10123   10123   10123 /*gid egid sgid fsgid*/
FDSize: 256 /*文件描述符的最大个数，file-&gt;fds*/
Groups: 50123 /*启动该进程的用户所属的组的id*/
VmPeak:   960944 kB /*进程地址空间的大小*/
VmSize:   923620 kB /*进程虚拟地址空间的大小reserved_vm：进程在预留或特殊的内存间的物理页*/
VmLck:         0 kB /*进程已经锁住的物理内存的大小.锁住的物理内存不能交换到硬盘*/
VmPin:         0 kB
VmHWM:     31468 kB /*文件内存映射和匿名内存映射的大小*/
VmRSS:     31468 kB /*应用程序正在使用的物理内存的大小，就是用ps命令的参数rss的值 (rss)*/
VmData:    18428 kB /*程序数据段的大小（所占虚拟内存的大小），存放初始化了的数据*/
VmStk:       136 kB /*进程在用户态的栈的大小*/
VmExe:        20 kB /*程序所拥有的可执行虚拟内存的大小,代码段,不包括任务使用的库 */
VmLib:     61212 kB /*被映像到任务的虚拟内存空间的库的大小*/
VmPTE:       192 kB /*该进程的所有页表的大小*/
VmSwap:    13144 kB
Threads:        12 /*共享使用该信号描述符的任务的个数*/
SigQ:   0/14462 /*待处理信号的个数/目前最大可以处理的信号的个数*/
SigPnd: 0000000000000000 /*屏蔽位，存储了该线程的待处理信号*/
ShdPnd: 0000000000000000 /*屏蔽位，存储了该线程组的待处理信号*/
SigBlk: 0000000000001204 /*存放被阻塞的信号*/
SigIgn: 0000000000000000 /*存放被忽略的信号*/
SigCgt: 00000002000094f8 /*存放被俘获到的信号*/
CapInh: 0000000000000000 /*能被当前进程执行的程序的继承的能力*/
CapPrm: 0000000000000000 /*进程能够使用的能力，可以包含CapEff中没有的能力，这些能力是被进程自己临时放弃的*/
CapEff: 0000000000000000 /*是CapPrm的一个子集，进程放弃没有必要的能力有利于提高安全性*/
CapBnd: fffffff000000000
Cpus_allowed:   f /*可以执行该进程的CPU掩码集*/
Cpus_allowed_list:      0-3
voluntary_ctxt_switches:        258 /*进程主动切换的次数*/
nonvoluntary_ctxt_switches:     201 /*进程被动切换的次数*/
</code></pre><p>由于其余字段对我们的CrackMe分析来说并不是很重要，有兴趣扩展的同学可以看这篇文章</p>
<p>Linux内核之旅：<a href="http://www.kerneltravel.net/?p=294">proc文件系统探索之以数字命名的目录[四]</a></p>
<p>那么我们来使用IDA attach我写好的一个Helloworld Demo</p>
<p>先设置<code>ro.debuggable</code>为1</p>
<pre><code>root@jflte:/data # ./mprop ro.debuggable 1
</code></pre><p>运行<code>android_server</code></p>
<pre><code>C:\Users\wangz&gt;adb shell
 root@jflte:/ # cd data/local
root@jflte:/data/local # ./as
IDA Android 32-bit remote debug server(ST) v1.19. Hex-Rays (c) 2004-2015
Listening on port #23946...
</code></pre><p>转发23946端口</p>
<pre><code>C:\Users\wangz&gt;adb forward tcp:23946 tcp:23946
</code></pre><p>开DDMS或者Android Device Monitor</p>
<p>选中我们要调试的程序，一定要点击选中</p>
<p>使用IDA attach</p>
<p>观察<code>TracerPid</code>字段，发现变成了8319，<code>State</code>字段也变成了<code>tracing stop</code></p>
<pre><code>root@jflte:/ # cat /proc/29139/status
Name:   n.myapplication
State:  t (tracing stop)
Tgid:   29139
Pid:    29139
PPid:   281
TracerPid:      8319
Uid:    10123   10123   10123   10123
Gid:    10123   10123   10123   10123
FDSize: 256
Groups: 50123
VmPeak:   961076 kB
VmSize:   923620 kB
VmLck:         0 kB
VmPin:         0 kB
VmHWM:     32216 kB
VmRSS:     32216 kB
VmData:    18428 kB
VmStk:       136 kB
VmExe:        20 kB
VmLib:     61212 kB
VmPTE:       192 kB
VmSwap:    13132 kB
Threads:        12
SigQ:   0/14462
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 0000000000001204
SigIgn: 0000000000000000
SigCgt: 00000002000094f8
CapInh: 0000000000000000
CapPrm: 0000000000000000
CapEff: 0000000000000000
CapBnd: fffffff000000000
Cpus_allowed:   f
Cpus_allowed_list:      0-3
voluntary_ctxt_switches:        577
nonvoluntary_ctxt_switches:     315
</code></pre><p>那么8319是什么？</p>
<p>使用ps命令查看</p>
<pre><code>root@jflte:/ # ps |grep 8319
root      8319  8277  12700  10968 ffffffff b6f324c4 S ./android_server
</code></pre><p>原来是我们的android_server程序，那么看到这里，大家应该有一些理解了，当我们使用IDA attach程序的时候，在<code>/proc/{PID}/status</code>文件的<code>TracerPid</code>字段会写入调试程序的PID</p>
<p>也就是说使用<code>TracerPid</code>反调试的原理就是检测这个字段是否为0，为0说明没有被调试，不为0说明正在被调试，检测调试器直接退出就可以达到反调试的效果</p>
<p>接下来我们来实现具体的代码</p>
<p>创建一个<code>AntiDebug</code>文件夹，创建一个<code>antidebug.cpp</code>，一个<code>antidebug.h</code></p>
<p>头文件可以在创建<code>C++ Source File</code>的时候选中<code>Create an associated header</code>自动创建</p>
<p>先在<code>antidebug.h</code>里引入各种头文件</p>
<pre><code>//
// Created by wnagzihxain on 2016/12/25 0025.
//


#ifndef MYAPPLICATION_ANTIDEBUG_H
#define MYAPPLICATION_ANTIDEBUG_H

#include &lt;stdio.h&gt;
#include &lt;sys/ptrace.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;android/log.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;sys/inotify.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sys/prctl.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;signal.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/queue.h&gt;
#include &lt;sys/select.h&gt;

#endif //MYAPPLICATION_ANTIDEBUG_H
</code></pre><p>在<code>antidebug.cpp</code>实现一下反调试函数</p>
<pre><code>//
// Created by wnagzihxain on 2016/12/25 0025.
//

#include &quot;antidebug.h&quot;

#define NULL 0
#define CHECK_TIME 10
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, &quot;totoc&quot;, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, &quot;totoc&quot;, __VA_ARGS__)


pthread_t id_anti_debug = NULL;

void readStatus() {
    FILE *fd;
    char filename[128];
    char line[128];
    pid_t pid = syscall(__NR_getpid);
    LOGI(&quot;PID : %d&quot;, pid);
    sprintf(filename, &quot;/proc/%d/status&quot;, pid);// 读取proc/pid/status中的TracerPid
    while (1) {
        fd = fopen(filename, &quot;r&quot;);
        while (fgets(line, 128, fd)) {
            if (strncmp(line, &quot;TracerPid&quot;, 9) == 0) {
                int status = atoi(&amp;line[10]);
                LOGI(&quot;########## status = %d, %s&quot;, status, line);
                fclose(fd);
                syscall(__NR_close, fd);
                if (status != 0) {
                    LOGI(&quot;########## FBI WARNING ##########&quot;);
                    LOGI(&quot;######### FIND DEBUGGER #########&quot;);
                    kill(pid, SIGKILL);
                    return;
                }
                break;
            }
        }
        sleep(CHECK_TIME);
    }
}

void checkAnti() {
    LOGI(&quot;Call readStatus...&quot;);
    readStatus();
}

void anti_debug() {
    LOGI(&quot;Call anti_debug...&quot;);
    if (pthread_create(&amp;id_anti_debug, NULL, (void *(*)(void *)) &amp;checkAnti, NULL) != 0) {
        LOGE(&quot;Failed to create a debug checking thread!&quot;);
        exit(-1);
    };
    pthread_detach(id_anti_debug);
}
</code></pre><p>然后写一个JNI_OnLoad调用动态注册一个函数是为了后续的测试，可以不需要注册函数相关</p>
<pre><code>//
// Created by wnagzihxain on 2016/12/17 0017.
//

#include &lt;iostream&gt;
#include &quot;android/log.h&quot;
#include &quot;AntiDebug/antidebug.h&quot;
#include &quot;totoc.h&quot;

using namespace std;

#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, &quot;totoc&quot;, __VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, &quot;totoc&quot;, __VA_ARGS__)


static const char *gClassName = &quot;com/wnagzihxain/myapplication/MainActivity&quot;;

/*
 * Class:     com_wnagzihxain_myapplication_MainActivity
 * Method:    getStringFromNative
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL getStringFromNative(JNIEnv *env, jclass obj) {
    //LOGI(&quot;getString : Hello From JNI&quot;);
    return env-&gt;NewStringUTF(&quot;Hello From JNI!&quot;);
}

static JNINativeMethod gMethods[] = {
        {&quot;getStringFromNative&quot;, &quot;()Ljava/lang/String;&quot;, (void *) getStringFromNative},
};

static int registerNativeMethods(JNIEnv *env, const char *className, JNINativeMethod *gMethods, int numMethods) {
    jclass clazz;
    clazz = env-&gt;FindClass(className);
    if (clazz == NULL) {
        //LOGE(&quot;env-&gt;FindClass error&quot;);
        return JNI_FALSE;
    }
    if (env-&gt;RegisterNatives(clazz, gMethods, numMethods) &lt; 0) {
        //LOGE(&quot;env-&gt;RegisterNatives error&quot;);
        return JNI_FALSE;
    }
    return JNI_TRUE;
}

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env = NULL;
    jint result = -1;

    if (vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) {
        //LOGE(&quot;vm-&gt;GetEnv error&quot;);
        return result;
    }

    anti_debug();

    if (registerNativeMethods(env, gClassName, gMethods, sizeof(gMethods) / sizeof(gMethods[0])) == JNI_FALSE) {
        return -1;
    }

    return JNI_VERSION_1_6;
}
</code></pre><p>首先是<code>anti_debug()</code>函数，用于创建线程执行<code>chackAnti()</code>函数</p>
<p><code>chackAnti()</code>函数里面调用<code>readStatus()</code>，<code>readStatus()</code>是真正实现读取<code>TracerPid</code>字段实现反调试的函数，那么这里为什么要多写一个函数用于调用呢？</p>
<p>这里是因为：程序不仅仅可以通过检测<code>/proc/{PID}/status</code>文件的<code>TracerPid</code>字段是否为0来判断是否被调试，还有其它方法，比如检测23946端口，这个端口是<code>android_server</code>在占用，还可以各种方法，每一个方法要是都写在一个<code>readStatus()</code>里那就太混乱了，所以我们可以将每个反调试方法实现在各自单独的函数里，然后在<code>checkAnti()</code>里面集中调用</p>
<p>那么仔细读一下<code>anti_debug()</code>函数，是比较容易理解的，在子线程中循环检测，时间间隔是10秒，发现<code>TracerPid</code>字段的值不为0就发送一个<code>SIGKILL</code>信号，这个信号简单粗暴，其它信号进程都可以忽略掉，唯独这个信号不行，无条件终止指定进程，意思就是说：<strong>你个不要脸的都要调试我了，我就自杀！！！！！！</strong></p>
<p>我们attach一下看看效果</p>
<ul>
<li>android_sever跑起来监听23946端口</li><li>mprop设置ro.debuggable变量为1</li><li>转发23946端口</li></ul>
<pre><code>12-26 17:05:15.539 32038-32038/com.wnagzihxain.myapplication I/totoc: Call anti_debug...
12-26 17:05:15.549 32038-32054/com.wnagzihxain.myapplication I/totoc: Call readStatus...
12-26 17:05:15.549 32038-32054/com.wnagzihxain.myapplication I/totoc: PID : 32038
12-26 17:05:15.549 32038-32054/com.wnagzihxain.myapplication I/totoc: ########## status = 0, TracerPid:    0
12-26 17:05:25.548 32038-32054/com.wnagzihxain.myapplication I/totoc: ########## status = 0, TracerPid:    0
12-26 17:05:35.548 32038-32054/com.wnagzihxain.myapplication I/totoc: ########## status = 0, TracerPid:    0
12-26 17:05:45.548 32038-32054/com.wnagzihxain.myapplication I/totoc: ########## status = 0, TracerPid:    0
12-26 17:05:55.548 32038-32054/com.wnagzihxain.myapplication I/totoc: ########## status = 0, TracerPid:    0
12-26 17:06:05.547 32038-32054/com.wnagzihxain.myapplication I/totoc: ########## status = 0, TracerPid:    0
12-26 17:06:15.547 32038-32054/com.wnagzihxain.myapplication I/totoc: ########## status = 0, TracerPid:    0
</code></pre><p>从LogCat中可以看出来，确实是在不断地检测</p>
<p>我们来使用IDA attach</p>
<p>attch成功后会断在这里</p>
<p><img src="Image/1.png" alt=""></p>
<p>点击左上角的三角运行起来</p>
<p>可以看到程序退出，并且Android Device Monitor显示程序的状态是<code>DEAD</code>，LogCat里输出检测到调试器的信息</p>
<pre><code>12-26 17:08:24.383 32038-32054/com.wnagzihxain.myapplication I/totoc: ########## status = 4036, TracerPid:    4036
12-26 17:08:24.383 32038-32054/com.wnagzihxain.myapplication I/totoc: ########## FBI WARNING ##########
12-26 17:08:24.383 32038-32054/com.wnagzihxain.myapplication I/totoc: ######### FIND DEBUGGER #########
</code></pre><p>IDA也是一个<code>不太好</code>的状态，这个界面可以多留意一下，以后经常会遇到的</p>
<p><img src="Image/2.png" alt=""></p>
<p>基本效果虽然是达到了，但是我们发现，在IDA attach上程序之后，会断下来，并不会立刻断开，当我们运行起来之后，才会断开，所以我们可以改进一下，fork一个子进程出来，当父进程被attach之后，由子进程来检测父进程的<code>/proc/{PID}/status</code>文件，就可以实现IDA attach程序的时候立刻kill掉自己</p>
<p>改一下代码</p>
<pre><code>void readStatus() {
    FILE *fd;
    char filename[128];
    char line[128];
    pid_t pid = syscall(__NR_getpid);
    LOGI(&quot;PID : %d&quot;, pid);
    sprintf(filename, &quot;/proc/%d/status&quot;, pid);// 读取proc/pid/status中的TracerPid
    if (fork() == 0) {
        while (1) {
            fd = fopen(filename, &quot;r&quot;);
            while (fgets(line, 128, fd)) {
                if (strncmp(line, &quot;TracerPid&quot;, 9) == 0) {
                    int status = atoi(&amp;line[10]);
                    LOGI(&quot;########## status = %d, %s&quot;, status, line);
                    fclose(fd);
                    syscall(__NR_close, fd);
                    if (status != 0) {
                        LOGI(&quot;########## FBI WARNING ##########&quot;);
                        LOGI(&quot;######### FIND DEBUGGER #########&quot;);
                        kill(pid, SIGKILL);
                        return;
                    }
                    break;
                }
            }
            sleep(CHECK_TIME);
        }
    } else {
        LOGE(&quot;fork error&quot;);
    }
}
</code></pre><p><code>fork()</code>函数的作用是生成和父进程一模一样的子进程，它会和父进程一起执行一样的代码</p>
<p>当执行<code>fork()</code>函数的时候，会有三种返回值，一个是大于0的数，这个是返回给父进程的，这个数表示子进程的PID，一个是等于0，这个是返回给子进程的，那么在正常情况下是这样的，在不正常的情况下返回-1，表示<code>fork()</code>函数调用失败</p>
<p>既然正常情况下有两个返回值，那么我们就可以使用这两个不同的返回值来进行区分当前是父进程在执行还是子进程在执行</p>
<p>这里要注意一下源码的实现，我们使用的是返回值为0的情况，也就是说只实现了子进程，执行的时候，检测的是父进程的<code>/proc/{PID}/status</code>文件</p>
<p>运行起来，使用<code>ps</code>命令，可以看到有两个进程，10965是父进程</p>
<pre><code>root@jflte:/ # ps |grep &quot;wnagzihxain&quot;
u0_a124   10965 281   952676 31684 ffffffff 4005a8e0 S com.wnagzihxain.myapplication
u0_a124   10992 10965 909256 11836 c00a30b4 4005a028 S com.wnagzihxain.myapplication
</code></pre><p>LogCat的输出发现了<code>fork error</code>，这里并不是真正的fork失败，而是这是父进程，fork后返回值为子进程的PID，而我们LogCat输出端是父进程的日志，所以看到的是<code>fork error</code>，在子进程里，确实是在不断的检测父进程的<code>/proc/{PID}/status</code>文件</p>
<pre><code>12-26 17:47:56.037 10965-10965/com.wnagzihxain.myapplication I/totoc: Call anti_debug...
12-26 17:47:56.037 10965-10990/com.wnagzihxain.myapplication I/totoc: Call readStatus...
12-26 17:47:56.037 10965-10990/com.wnagzihxain.myapplication I/totoc: PID : 10965
12-26 17:47:56.047 10965-10990/com.wnagzihxain.myapplication E/totoc: fork error
12-26 17:47:56.097 10965-10965/com.wnagzihxain.myapplication I/totoc: getString : Hello From JNI
</code></pre><p>使用IDA attach父进程，选择PID为10965那个，根据LogCat的输出确定父进程</p>
<p>卡了一下，IDA挂了</p>
<p><img src="Image/3.png" alt=""></p>
<p>再使用ps命令，发现两个进程都挂了</p>
<pre><code>root@jflte:/ # ps |grep &quot;wnagzihxain&quot;
1|root@jflte:/ #
</code></pre><p>那这个效果是不错的</p>
<p>我们现在来attch子进程</p>
<p>依旧是先ps命令查看进程情况，21330是父进程，21353是子进程，千万记得，是通过LogCat判断哪个是父进程！！！！！！</p>
<pre><code>root@jflte:/ # ps |grep &quot;wnagzihxain&quot;
u0_a124   21330 281   944556 31536 ffffffff 4005a8e0 S com.wnagzihxain.myapplication
u0_a124   21353 21330 909256 12008 c00a30b4 4005a028 S com.wnagzihxain.myapplication
</code></pre><p>我们attach子进程</p>
<p><img src="Image/4.png" alt=""></p>
<p>发生了什么，竟然没有挂掉？？？？？？</p>
<p>是我们的代码出现错误了吗？？？？？？</p>
<p>从调试情况来看，是的，逻辑写的不太好</p>
<p>带着疑问，我们尝试运行起来，也没有挂掉</p>
<p>那么看来是代码考虑的情况不完全了</p>
<p>我们再来仔细的思考一下代码是不是哪里有问题</p>
<pre><code>void readStatus() {
    FILE *fd;
    char filename[128];
    char line[128];
    pid_t pid = syscall(__NR_getpid);
    LOGI(&quot;PID : %d&quot;, pid);
    sprintf(filename, &quot;/proc/%d/status&quot;, pid);// 读取/proc/pid/status中的TracerPid
    if (fork() == 0) {
        while (1) {
            fd = fopen(filename, &quot;r&quot;);
            while (fgets(line, 128, fd)) {
                if (strncmp(line, &quot;TracerPid&quot;, 9) == 0) {
                    int status = atoi(&amp;line[10]);
                    LOGI(&quot;########## status = %d, %s&quot;, status, line);
                    fclose(fd);
                    syscall(__NR_close, fd);
                    if (status != 0) {
                        LOGI(&quot;########## FBI WARNING ##########&quot;);
                        LOGI(&quot;######### FIND DEBUGGER #########&quot;);
                        kill(pid, SIGKILL);
                        return;
                    }
                    break;
                }
            }
            sleep(CHECK_TIME);
        }
    } else {
        LOGE(&quot;fork error&quot;);
    }
}
</code></pre><p>蓦然间，我们发现代码里只针对父进程做了反调试保护，而子进程却没有任何保护</p>
<p>我们在子进程中读取的是父进程的<code>/proc/{PID}/status</code>文件，kill的也是父进程</p>
<pre><code>fd = fopen(filename, &quot;r&quot;);
......
kill(pid, SIGKILL);
</code></pre><p>难怪我们刚才没有<code>FBI WARNING</code></p>
<p>搞清楚这些后，来修改一下代码</p>
<p>使用<code>PTRACE_TRACEME</code></p>
<pre><code>void readStatus() {
    FILE *fd;
    char filename[128];
    char line[128];
    pid_t pid = syscall(__NR_getpid);
    LOGI(&quot;PID : %d&quot;, pid);
    sprintf(filename, &quot;/proc/%d/status&quot;, pid);//读取/proc/pid/status中的TracerPid
    if (fork() == 0) {
        int pt = ptrace(PTRACE_TRACEME, 0, 0, 0); //子进程反调试
        if (pt == -1)
            exit(0);
        while (1) {
            fd = fopen(filename, &quot;r&quot;);
            while (fgets(line, 128, fd)) {
                if (strncmp(line, &quot;TracerPid&quot;, 9) == 0) {
                    int status = atoi(&amp;line[10]);
                    LOGI(&quot;########## status = %d, %s&quot;, status, line);
                    fclose(fd);
                    syscall(__NR_close, fd);
                    if (status != 0) {
                        LOGI(&quot;########## FBI WARNING ##########&quot;);
                        LOGI(&quot;######### FIND DEBUGGER #########&quot;);
                        kill(pid, SIGKILL);
                        return;
                    }
                    break;
                }
            }
            sleep(CHECK_TIME);
        }
    } else {
        LOGE(&quot;fork error&quot;);
    }
}
</code></pre><p>我们在子进程中使用ptrace，将请求类型设为<code>PTRACE_TRACEME</code>，表示让父进程跟踪自己，而进程在同一时间，只能被一个调试器调试或者跟踪，所以这里就是一个父进程，一个子进程，子进程通过读取父进程的<code>/proc/{PID}/status</code>文件保护父进程不被调试，同时让父进程跟踪自己，保护自己不被调试，如果ptrace失败，说明有调试器已经在调试自己，直接退出</p>
<p>运行起来，来看一下是不是和我们预期的一样</p>
<pre><code>root@jflte:/ # ps |grep &quot;wnagzihxain&quot;
u0_a124   22633 281   943504 31644 ffffffff 4005a8e0 S com.wnagzihxain.myapplication
u0_a124   22653 22633 909256 11872 c00a30b4 4005a028 S com.wnagzihxain.myapplication
root@jflte:/ # cat /proc/22633/status |grep &quot;TracerPid&quot;
TracerPid:      0
root@jflte:/ # cat /proc/22653/status |grep &quot;TracerPid&quot;
TracerPid:      22633
</code></pre><p>从结果来看，子进程确实是被父进程跟踪了</p>
<p>直观的效果我们使用IDA attach</p>
<p><img src="Image/5.png" alt=""></p>
<p>使用IDA进行逆向分析，编译的时候记得把LogCat给注释掉</p>
<p>左边有几个我们很眼熟的函数</p>
<p><img src="Image/6.png" alt=""></p>
<p>进入<code>JNI_OnLoad()</code>函数</p>
<p><img src="Image/7.png" alt=""></p>
<p>跟进这个调用，也就是我们的反调试函数</p>
<p><img src="Image/8.png" alt=""></p>
<p>分析一下代码</p>
<p>导出函数和函数名</p>
<pre><code>.text:0000126C ; _DWORD anti_debug(void)
.text:0000126C EXPORT _Z10anti_debugv
.text:0000126C _Z10anti_debugv
</code></pre><p>将0赋值给R1：<code>R1 = 0</code></p>
<pre><code>.text:0000126C MOVS    R1, #0          ; attr
</code></pre><p>将R4和LR寄存器的值压栈</p>
<pre><code>.text:0000126E PUSH    {R4,LR}
</code></pre><p>重定位操作：<code>R4 = id_anti_debug_ptr - 0x127A</code>，这个地方有个小技巧，IDA识别出来的字符串有时候是用指针来表示的，如果表示指针的变量后面还有一个<code>_ptr</code>，表示的是这是指针的指针，或者说指针的地址，比如<code>*string = &quot;Goodmorning&quot;</code>，<code>string</code>就表示它的指针或者首地址，那么<code>string_str</code>表示的就是指针的地址，也就是<code>string = *string_str</code></p>
<pre><code>.text:00001270 LDR     R4, =(id_anti_debug_ptr - 0x127A)
</code></pre><p>重定位操作：<code>R2 = _Z9checkAntiv_ptr - 0x127A</code>，这个也是表示指针的指针</p>
<pre><code>.text:00001272 LDR     R2, =(_Z9checkAntiv_ptr - 0x127E)
</code></pre><p>将R1的值赋值给R3：<code>R3 = R1</code></p>
<pre><code>.text:00001274 MOVS    R3, R1          ; arg
</code></pre><p>此时PC为<code>0x127A</code>：<code>R4 = id_anti_debug_ptr</code></p>
<pre><code>.text:00001276 ADD     R4, PC ; id_anti_debug_ptr
</code></pre><p>取出R4地址上的值赋值给R4：<code>R4 = [R4]</code>，取出这个指针的地址上的值，这下R4真的存储的是<code>id_anti_debug</code>的地址或者说它的指针</p>
<pre><code>.text:00001278 LDR     R4, [R4] ; id_anti_debug
</code></pre><p>此时PC为<code>0x127E</code>：<code>R2 = _Z9checkAntiv_ptr</code></p>
<pre><code>.text:0000127A ADD     R2, PC ; _Z9checkAntiv_ptr
</code></pre><p>取出R2地址上的值赋值给R2：<code>R2 = [R2]</code>，R2此时存储的是<code>checkAnti(void)</code>方法的指针</p>
<pre><code>.text:0000127C LDR     R2, [R2] ; checkAnti(void) ; start_routine
</code></pre><p>将R4的值赋值给R0：<code>R0 = R4</code></p>
<pre><code>.text:0000127E MOVS    R0, R4          ; newthread
</code></pre><p>调用<code>j_j_pthread_create()</code>，此时R0为线程标识符的指针，R1为0，R2为<code>checkAnti(void)</code>函数指针，R3为0</p>
<pre><code>.text:00001280 BL      j_j_pthread_create
</code></pre><p>对比返回值是否为0</p>
<pre><code>.text:00001284 CMP     R0, #0
</code></pre><p>返回值为0表示线程创建成功，当线程结束跳转到正常结束分支</p>
<pre><code>.text:00001286 BEQ     loc_1290
</code></pre><p>正常结束分支</p>
<pre><code>.text:00001290 loc_1290                ; th
.text:00001290 LDR     R0, [R4]
.text:00001292 BL      j_j_pthread_detach
.text:00001296 POP     {R4,PC}
.text:00001296 ; End of function anti_debug(void)
</code></pre><p>当返回值不为0表示线程创建失败，则退出</p>
<pre><code>.text:00001288 MOVS    R0, #1
.text:0000128A NEGS    R0, R0
.text:0000128C BL      j_j_exit
</code></pre><p>进入创建线程运行的函数<code>checkAnti(void)</code></p>
<p><img src="Image/9.png" alt=""></p>
<p>调用<code>readStatus(void)</code>函数</p>
<pre><code>00001266 BL      _Z10readStatusv ; readStatus(void)
</code></pre><p>继续跟入</p>
<p><img src="Image/10.png" alt=""></p>
<p>这里是一个非常常见的IDA识别错误，从整个逻辑调用来看，这个函数有多个入口，但是从我们的经验来说，函数入口应该有变量的或者参数，那么明显，左下角红色框框里面才是入口，我们来修正一下</p>
<p>这个修正我在Ericky师傅那个CrackMe的WriteUp里面有提到过，那个也是需要先修正</p>
<p>点击这个函数的BX指令或者说是选中</p>
<p><img src="Image/11.png" alt=""></p>
<p>单击<code>Remove Function Tail</code></p>
<p><img src="Image/12.png" alt=""></p>
<p>然后这个代码块就悬空了</p>
<p><img src="Image/13.png" alt=""></p>
<p>选中红框内的BL指令，然后点击<code>Force BL call</code></p>
<p><img src="Image/14.png" alt=""></p>
<p>那么整个函数的逻辑调用就修复了</p>
<p><img src="Image/15.png" alt=""></p>
<p>继续继续看代码</p>
<p>最开始定义五个变量，其实从变量的命名之间我们是可以推敲出一点东西的，比如<code>0x11C</code>和<code>0x9C</code>之间的间隔是128，说明这里有一个变量占用128byte，那它可能是一个数组，同样，<code>0x9C</code>和<code>0x1C</code>之间间隔128byte，也可能是一个数组</p>
<pre><code>.text:000011A4 var_124= -0x124
.text:000011A4 var_120= -0x120
.text:000011A4 var_11C= -0x11C
.text:000011A4 s= -0x9C
.text:000011A4 var_1C= -0x1C
</code></pre><p>将R4，R5，R6，R7，LR寄存器的值压栈</p>
<pre><code>.text:000011A4 PUSH    {R4-R7,LR}
</code></pre><p>重定位<code>__stack_chk_guard_ptr</code>，在前面我们提到，后面跟着ptr的是这个变量指针的指针，这里是：<code>R4 = __stack_chk_guard_ptr - 0x11B0</code></p>
<pre><code>.text:000011A6 LDR     R4, =(__stack_chk_guard_ptr - 0x11B0)
</code></pre><p>抬高栈顶，开辟<code>0x114</code>byte大小的空间</p>
<pre><code>.text:000011A8 SUB     SP, SP, #0x114
</code></pre><p><code>0x14</code>是20，将20赋值给R0：<code>R0 = 0x14</code></p>
<pre><code>.text:000011AA MOVS    R0, #0x14       ; sysno
</code></pre><p>这个是一个保护机制，可以不用管</p>
<pre><code>.text:000011AC ADD     R4, PC ; __stack_chk_guard_ptr
.text:000011AE LDR     R4, [R4] ; __stack_chk_guard
</code></pre><p>将SP加上<code>#0x128+var_11C</code>的值赋值给R6，其实这里是不需要计算出来的，因为这里的<code>var_11C</code>虽然代表的是偏移，但是在程序中使用的时候，可以看到跟这个变量有关的计算都是指向同一个内存地址，如果是有过一些分析经验的同学一定是可以理解我说的这句话的，如果没有经验的同学尝试着多分析几个小程序，再回头来看看我这句话，肯定会有所理解的</p>
<pre><code>.text:000011B0 ADD     R6, SP, #0x128+var_11C
</code></pre><p>取R4地址上的值给R3，往上两行可以看到这是<code>__stack_chk_guard</code>的指针</p>
<pre><code>.text:000011B2 LDR     R3, [R4]
</code></pre><p>将R3也就是<code>*__stack_chk_guard</code>存储到<code>[SP,#0x128+var_1C]</code>，其实<code>var_1C</code>就可以重命名为<code>__stack_chk_guard</code></p>
<pre><code>.text:000011B4 STR     R3, [SP,#0x128+var_1C]
</code></pre><p>调用<code>j_j_syscall()</code>函数，这一句的源码对应：<code>pid_t pid = syscall(__NR_getpid)</code></p>
<pre><code>.text:000011B6 BL      j_j_syscall
</code></pre><p>上一句的返回值是当前进程的PID，存储在R0中，这里将R0的值赋值给R5：<code>R5 = PID</code></p>
<pre><code>.text:000011BA MOVS    R5, R0
</code></pre><p>重定位<code>aProcDStatus</code>，这里是：<code>R1 = aProcDStatus - 0x11C4</code></p>
<pre><code>.text:000011BC LDR     R1, =(aProcDStatus - 0x11C4)
</code></pre><p>将R5赋值给R2，R5存储的是PID，也就是：<code>R2 = PID</code></p>
<pre><code>.text:000011BE MOVS    R2, R5
</code></pre><p>重定位过后，R1指向<code>aProcDStatus</code>：<code>R1 = &quot;/proc/%d/status&quot;</code></p>
<pre><code>.text:000011C0 ADD     R1, PC          ; &quot;/proc/%d/status&quot;
</code></pre><p>将R6赋值给R0，往上翻，找到R6，R6存储的是<code>var_11C</code>这个变量，这个变量在前面我们简单提到过，占用128byte的空间</p>
<pre><code>.text:000011C2 MOVS    R0, R6          ; s
</code></pre><p>调用<code>j_j_sprintf()</code>函数，还原一下：<code>sprintf(var_11C, &quot;/proc/%d/status&quot;, PID)</code>，这样一看就清楚多了，var_11C表示的就是该进程<code>status</code>文件的路径</p>
<pre><code>.text:000011C4 BL      j_j_sprintf
</code></pre><p>调用<code>fork()</code>函数，没有参数</p>
<pre><code>.text:000011C8 BL      j_j_fork
</code></pre><p>将R4存储到<code>[SP,#0x128+var_124]</code>,R4是<code>__stack_chk_guard</code>的指针的指针</p>
<pre><code>.text:000011CC STR     R4, [SP,#0x128+var_124]
</code></pre><p>将R0减0赋值给R7：<code>R7 = R0</code></p>
<pre><code>.text:000011CE SUBS    R7, R0, #0
</code></pre><p>判断返回结果跳转</p>
<pre><code>.text:000011D0 BNE     loc_1240
</code></pre><p>不为0就跳到最后结束线程，这一段是安全性的校验</p>
<pre><code>.text:00001240
.text:00001240             loc_1240
.text:00001240 01 9B       LDR     R3, [SP,#0x128+var_124]
.text:00001242 43 9A       LDR     R2, [SP,#0x128+var_1C]
.text:00001244 1B 68       LDR     R3, [R3]
.text:00001246 9A 42       CMP     R2, R3
.text:00001248 01 D0       BEQ     loc_124E
</code></pre><p>如果<code>fork()</code>的返回值不为0，进入反调试逻辑</p>
<p>将R7赋值给R3，R7的直观含义是<code>fork()</code>返回值减去0，那么这里就是：<code>R3 = 0</code></p>
<pre><code>.text:000011D2 3B 1C       MOVS    R3, R7
</code></pre><p>将R7赋值给R1：<code>R1 = 0</code></p>
<pre><code>.text:000011D4 39 1C       MOVS    R1, R7
</code></pre><p>将R7赋值给R2：<code>R2 = 0</code></p>
<pre><code>.text:000011D6 3A 1C       MOVS    R2, R7
</code></pre><p>调用<code>j_j_ptrace()</code>函数，这里四个参数<code>R0-R3</code>全是0，还原一下：<code>ptrace(0, 0, 0, 0)</code>，对应源码：<code>ptrace(PTRACE_TRACEME, 0, 0, 0)</code></p>
<pre><code>.text:000011D8 01 F0 42 FB BL      j_j_ptrace
</code></pre><p>返回值给R0，这里R0加1赋值给R3，这里是有点不一样的，<code>j_j_ptrace()</code>调用失败会返回<code>-1</code>，就是说，R0如果为<code>-1</code>，加上1结果就是0，再将这个结果赋值给R3，这个就影响后面的逻辑跳转了</p>
<pre><code>.text:000011DC 43 1C       ADDS    R3, R0, #1
</code></pre><p>这个跳转就看<code>j_j_ptrace()</code>方法返回值了</p>
<pre><code>.text:000011DE 15 D1       BNE     loc_120C
</code></pre><p>返回值为<code>-1</code>时的分支，直接就退出程序了</p>
<pre><code>.text:000011E0 38 1C       MOVS    R0, R7          ; status
.text:000011E2 01 F0 45 FB BL      j_j_exit
</code></pre><p>当返回值不为<code>-1</code></p>
<pre><code>.text:0000120C
.text:0000120C             loc_120C
</code></pre><p>重定位<code>aR</code>，那么：<code>R1 = aR - 0x1214</code></p>
<pre><code>.text:0000120C 14 49       LDR     R1, =(aR - 0x1214)
</code></pre><p>R6的值往上翻找一找，对应的是<code>&quot;/proc/%d/status&quot;</code>，虽然这里有字符串提醒</p>
<pre><code>.text:0000120E 30 1C       MOVS    R0, R6          ; filename
</code></pre><p>重定位完成，此时：<code>R1 = &quot;r&quot;</code></p>
<pre><code>.text:00001210 79 44       ADD     R1, PC          ; &quot;r&quot;
</code></pre><p>调用<code>j_j_fopen()</code>函数，还原一下：<code>fopen(&quot;/proc/PID/status&quot;, &quot;r&quot;)</code>，需要注意的是，此时PID的值已经获取到了，并不是一个未知的变量或者说是参数</p>
<pre><code>.text:00001212 01 F0 4D FB BL      j_j_fopen
</code></pre><p>返回的结果为R0，赋值给R4，它返回的结果是一个<code>FILE *</code>类型的参数</p>
<pre><code>.text:00001216 04 1C       MOVS    R4, R0
</code></pre><p>无条件跳转到<code>loc_11F6</code></p>
<pre><code>.text:00001218 ED E7       B       loc_11F6
</code></pre><p>跟下来</p>
<pre><code>.text:000011F6
.text:000011F6             loc_11F6
</code></pre><p>将<code>SP + #0x128 + s</code>相加赋值给R7，s变量占用的空间也是128byte，说明可能也是数组</p>
<pre><code>.text:000011F6 23 AF       ADD     R7, SP, #0x128+s
</code></pre><p>将R7赋值给R0：<code>R0 = R7</code>，R7是s变量的指针</p>
<pre><code>.text:000011F8 38 1C       MOVS    R0, R7          ; s
</code></pre><p>将<code>0x80</code>赋值给R1，<code>0x80</code>刚好是128：<code>R1 = 0x80</code></p>
<pre><code>.text:000011FA 80 21       MOVS    R1, #0x80       ; n
</code></pre><p>将R4赋值给R2，此时R4的值是一个<code>FILE *</code>类型的参数</p>
<pre><code>.text:000011FC 22 1C       MOVS    R2, R4          ; stream
</code></pre><p>调用<code>j_j_fgets()</code>函数，还原一下：<code>fgets((char *)s, 128, (FILE *)R4)</code>，这个地方有个换行符的问题需要注意，当两行之间是一个空行，fgets读取并不会退出，因为还没有结束，而且读取空行的长度不是0，是1，因为换行符占一个字节</p>
<pre><code>.text:000011FE 01 F0 47 FB BL      j_j_fgets
</code></pre><p>判断是否读取到了数据</p>
<pre><code>.text:00001202 00 28       CMP     R0, #0
</code></pre><p>根据是否还有数据进行跳转判断</p>
<pre><code>.text:00001204 EF D1       BNE     loc_11E6
</code></pre><p>没数据了跳到<code>loc_1240</code>，也就是结束的分支</p>
<p>如果还有数据，不为空，跳到<code>loc_11E6</code></p>
<pre><code>.text:000011E6
.text:000011E6             loc_11E6
</code></pre><p>重定位<code>aTracerpid</code>：<code>R1 = aTracerpid - 0x11EE</code></p>
<pre><code>.text:000011E6 1D 49       LDR     R1, =(aTracerpid - 0x11EE)
</code></pre><p>将R7的值赋值给R0，R7的值是s变量的指针，或者说是s数组的首地址：<code>R0 = (char *)s</code></p>
<pre><code>.text:000011E8 38 1C       MOVS    R0, R7          ; s1
</code></pre><p>重定位完成：<code>R1 = &quot;TracerPid&quot;</code></p>
<pre><code>.text:000011EA 79 44       ADD     R1, PC          ; &quot;TracerPid&quot;
</code></pre><p>将9赋值给R2：<code>R2 = 9</code></p>
<pre><code>.text:000011EC 09 22       MOVS    R2, #9          ; n
</code></pre><p>调用<code>j_j_jstrcmp()</code>方法，还原一下：<code>strcmp(s, &quot;TracerPid&quot;, 9)</code>，这个意思就是在比较读取到的数据前9个字节和<code>&quot;TracerPid&quot;</code>这个字符串比较</p>
<pre><code>.text:000011EE 01 F0 47 FB BL      j_j_strncmp
</code></pre><p>判断是否相等，也就是说是否读取到了<code>&quot;TracerPid&quot;</code>这个字段</p>
<pre><code>.text:000011F2 00 28       CMP     R0, #0
</code></pre><p>根据结果进行跳转</p>
<pre><code>.text:000011F4 11 D0       BEQ     loc_121A
</code></pre><p>如果不一样，跳回<code>loc_11F6</code>继续循环读取</p>
<p>如果一样，说明读取到了<code>&quot;TracerPid&quot;</code>这个字符串，那么跳转到<code>loc_121A</code></p>
<pre><code>.text:0000121A
.text:0000121A             loc_121A
</code></pre><p>将<code>0x8E</code>赋值给R0：<code>R0 = 0x8E</code></p>
<pre><code>.text:0000121A 8E 20       MOVS    R0, #0x8E
</code></pre><p><code>var_120</code>在定义中是一个4字节的变量，那么R3此时指向的就是这个变量</p>
<pre><code>.text:0000121C 02 AB       ADD     R3, SP, #0x128+var_120
</code></pre><p>将R0加上R3赋值给R0：<code>R0 = R0 + R3</code></p>
<pre><code>.text:0000121E C0 18       ADDS    R0, R0, R3      ; nptr
</code></pre><p>调用<code>j_j_atoi()</code>方法，这个方法用于将字符串转换为整型，还原一下：<code>atoi(R0)</code>，那这句在这里什么意思呢？R0指向的是什么数据呢？<code>var_120</code>前面也没有赋值，我们再回到前面，R7是s数组的首地址，我们每读取一行都会存在s里，s变量与<code>var_120</code>隔着132byte，而且数据是往下填充，那么这里的<code>0x8E</code>的作用是影响<code>var_120</code>，这里千万要理解，并不是影响<code>SP, #0x128+var_120</code>这一整个，而是影响<code>var_***</code>，因为我们在定位栈中变量就是靠的这个偏移，所以这里应该是<code>0x8E + var_120 = 0x8E - 0x120 = -0x92</code>，如果按照IDA的命名，这个差值应该是<code>var_92</code>，完整的表达方式应该是<code>SP, #0x128+var_92</code>，那现在就清楚了，<code>atoi()</code>函数的参数是以<code>[SP, #0x128+var_92]</code>为起始地址的字符串，那么这个地址的数据又要和s关联起来分析，s在栈中的位置是<code>SP, #0x128+(-0x9C)</code>，<code>0x9C</code>和<code>0x92</code>差值是10，也就是说，<code>atoi()</code>方法的参数是读取的字符下标为10开始的字符串，这里已经弄清楚要读取的是前9个字节为<code>&quot;TracerPid&quot;</code>的字符串，但是<code>&quot;TracerPid&quot;</code>只有9个字节，从0开始数下标的话只到8，为什么会从10开始呢？这里是因为<code>&quot;TracerPid&quot;</code>后面还有个&quot;:&quot;，所以这样加起来，<code>&quot;TracerPid:&quot;</code>就有10个字符，下标到第9，下标为10的字符开始刚好是<code>&quot;TracerPid&quot;</code>对应的值，我们调用<code>atoi()</code>就可以获取到需要的数据</p>
<pre><code>.text:00001220 01 F0 4E FB BL      j_j_atoi
</code></pre><p>将返回值R0赋值给R7：<code>R7 = R0</code>，R0此时是<code>TracerPid</code>的值</p>
<pre><code>.text:00001224 07 1C       MOVS    R7, R0
</code></pre><p>将R4赋值给R0，R4是<code>FILE *</code>类型的变量</p>
<pre><code>.text:00001226 20 1C       MOVS    R0, R4          ; stream
</code></pre><p>调用<code>j_j_fclose()</code>关闭文件流指针，也就是上面说的<code>FILE *</code>变量</p>
<pre><code>.text:00001228 01 F0 52 FB BL      j_j_fclose
</code></pre><p>将6赋值给R0：<code>R0 = 6</code></p>
<pre><code>.text:0000122C 06 20       MOVS    R0, #6          ; sysno
</code></pre><p>将R4赋值给R1：<code>R1 = R4</code></p>
<pre><code>.text:0000122E 21 1C       MOVS    R1, R4
</code></pre><p>系统调用，源码对应：<code>syscall(__NR_close, fd);</code></p>
<pre><code>.text:00001230 01 F0 FE FA BL      j_j_syscall
</code></pre><p>判断R7是否为0，R7是<code>TracerPid</code>的值</p>
<pre><code>.text:00001234 00 2F       CMP     R7, #0
</code></pre><p>根据结果跳转</p>
<pre><code>.text:00001236 E6 D0       BEQ     loc_1206
</code></pre><p>不为0说明被调试，直接kill自己，源码对应：<code>kill(pid, SIGKILL)</code></p>
<pre><code>.text:00001238 28 1C       MOVS    R0, R5          ; pid
.text:0000123A 09 21       MOVS    R1, #9          ; sig
.text:0000123C 01 F0 50 FB BL      j_j_kill
</code></pre><p>如果为0，睡眠10秒</p>
<pre><code>.text:00001206
.text:00001206             loc_1206                ; seconds
.text:00001206 0A 20       MOVS    R0, #0xA
.text:00001208 01 F0 4A FB BL      j_j_sleep
</code></pre><p>然后就继续回去读取文件，循环走下去</p>
<p>分析完了汇编，看一下F5之后的伪代码，有几处是要特别注意的，比如<code>syscall(__NR_getpid)和syscall(20)</code>，<code>ptrace(TRACE_TRACEME, 0, 0, 0)和ptrace(0, 0, 0, 0)</code>等这些反编译后对应的关系</p>
<pre><code>__pid_t readStatus(void)
{
  __int32 v0; // r5@1
  __pid_t result; // r0@1
  int v2; // r7@1
  FILE *v3; // r4@7
  int v4; // r7@8
  char v5; // [sp+Ch] [bp-11Ch]@1
  char s; // [sp+8Ch] [bp-9Ch]@4
  __int16 v7; // [sp+96h] [bp-92h]@8
  int v8; // [sp+10Ch] [bp-1Ch]@1

  v8 = _stack_chk_guard;
  v0 = j_j_syscall(20);
  j_j_sprintf(&amp;v5, &quot;/proc/%d/status&quot;, v0);
  result = j_j_fork();
  v2 = result;
  if ( !result )
  {
    if ( j_j_ptrace(0, 0, 0, 0) == -1 )
      j_j_exit(v2);
LABEL_7:
    v3 = j_j_fopen(&amp;v5, &quot;r&quot;);
    do
    {
      if ( !j_j_fgets(&amp;s, 128, v3) )
      {
LABEL_6:
        j_j_sleep(0xAu);
        goto LABEL_7;
      }
    }
    while ( j_j_strncmp(&amp;s, &quot;TracerPid&quot;, 9u) );
    v4 = j_j_atoi((const char *)&amp;v7);
    j_j_fclose(v3);
    j_j_syscall(6, v3);
    if ( !v4 )
      goto LABEL_6;
    result = j_j_kill(v0, 9);
  }
  if ( v8 != _stack_chk_guard )
    j_j___stack_chk_fail(result);
  return result;
}
</code></pre><p>关于这里的<code>syscall()</code>系统调用，推荐一篇文章</p>
<p>up哥小号的ChinaUnix博客：<a href="http://blog.chinaunix.net/uid-28362602-id-3424404.html">Linux 编程中的API函数和系统调用的关系</a></p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
