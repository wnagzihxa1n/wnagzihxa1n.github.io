<!DOCTYPE html>
<html>
<head>
<title>WriteUp-Ericky-CrackMe-20161017</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="writeup-ericky-crackme-20161017">WriteUp-Ericky-CrackMe-20161017</h1>
<p><strong>Author：wnagzihxain<br>Mail：tudouboom@163.com</strong></p>
<p>雨神的一个CrackMe，非常适合有一定的Java层逆向经验同时想进阶native层逆向的同学</p>
<p>那么我们现在就来详细的讲讲这个CrackMe的分析步骤以及分析的一些技巧</p>
<p>JEB载入，可以看到注册码和注册按钮相关的代码</p>
<pre><code>public class RegActivity extends Activity {
    public Button btn_reg;
    public EditText edit_sn;

    public RegActivity() {
        super();
    }

    public void onCreate(Bundle arg3) {
        super.onCreate(arg3);
        this.setTitle(&quot;写个Crackme好难啊！&quot;);
        this.setContentView(2130903065);
        this.btn_reg = this.findViewById(2131034139);
        this.edit_sn = this.findViewById(2131034138);
        this.btn_reg.setOnClickListener(new KeyListener(this));
    }
}
</code></pre><p>跟进注册按钮的点击事件</p>
<pre><code>public class KeyListener implements View$OnClickListener {
    private RegActivity RegActivity;

    public KeyListener(RegActivity arg1) {
        super();
        this.RegActivity = arg1;
    }

    public void onClick(View arg6) {
        DialogInterface$OnClickListener v1 = null;
        this.RegActivity.btn_reg.setEnabled(false);
        String v2 = this.RegActivity.edit_sn.getText().toString().trim();
        int v0 = v2.length();
        if(v2 == null || v0 == 0) {
            new AlertDialog$Builder(this.RegActivity).setTitle(&quot;Message:&quot;)
                .setMessage(&quot;Sorry,Fish!&quot;).setPositiveButton(&quot;OK&quot;, v1).show();
        }
        else if(JNI.EatRice(v2, v0)) {
            new AlertDialog$Builder(this.RegActivity).setTitle(&quot;Message:&quot;)
                .setMessage(&quot;Nice, Man!&quot;).setPositiveButton(&quot;OK&quot;, v1).show();
        }
        else {
            new AlertDialog$Builder(this.RegActivity).setTitle(&quot;Message:&quot;)
                .setMessage(&quot;Sorry, Fish!&quot;).setPositiveButton(&quot;OK&quot;, v1).show();
        }

        this.RegActivity.btn_reg.setEnabled(true);
    }
}
</code></pre><p>先判断了注册码是否为空，不为空则调用JNI.EatRice()方法</p>
<p>定义如下</p>
<pre><code>public class JNI {
    static {
        System.loadLibrary(&quot;xy&quot;);
    }

    public JNI() {
        super();
    }

    public static native boolean EatRice(String arg0, int arg1) {
    }
}
</code></pre><p>这是一个native函数，并且是静态方法，两个参数分别是string类型的注册码和int类型的注册码长度</p>
<p>从代码中可以看出这个函数在libxy.so中，所以接下来我们来分析libxy.so</p>
<p>IDA载入libxy.so</p>
<p>等待分析完成，找到Java_by_Ericky_crackme01_JNI_EatRice()方法，双击进入，那么反编译出来的汇编代码就是下面这个样子</p>
<p>上下翻一翻看看，可以看到这段代码还是比较有点长的</p>
<p><img src="http://www.wangzhixian.org/wp-content/uploads/2016/10/1.png" alt=""></p>
<p>一般来说，先F5看看大概是什么样子，很明显的可以发现汇编窗口代码明显是多于F5之后的代码，这是怎么一回事呢？</p>
<p><img src="http://www.wangzhixian.org/wp-content/uploads/2016/10/2.png" alt=""></p>
<p>这个其实是因为IDA在反编译so的时候，会出现一些识别的错误，这个很正常的，我们只需要人为的修正一下就好</p>
<p>回到反编译窗口，按一下空格来查看Graph View</p>
<p>可以看到IDA识别出了两个入口，那么很明显的，左边才是入口，右边那个应该是中间一个地方识别出错导致调用图断开</p>
<p><img src="http://www.wangzhixian.org/wp-content/uploads/2016/10/3.png" alt=""></p>
<p>那么就是红框选中的地方，这里识别有点问题</p>
<p><img src="http://www.wangzhixian.org/wp-content/uploads/2016/10/4.png" alt=""></p>
<p>单击红框中任意指令，然后如图点击</p>
<pre><code>Edit-&gt;Functions-&gt;Remove function tail
</code></pre><p><img src="http://www.wangzhixian.org/wp-content/uploads/2016/10/5.png" alt=""></p>
<p>点击完后会发现Graph View发生了变化</p>
<p><img src="http://www.wangzhixian.org/wp-content/uploads/2016/10/6.png" alt=""></p>
<p>这次单击里面的BL指令，然后如图点击</p>
<pre><code>Edit-&gt;others-&gt;Force BL call
</code></pre><p><img src="http://www.wangzhixian.org/wp-content/uploads/2016/10/7.png" alt=""></p>
<p>那么现在就可以看到整个函数的逻辑就恢复了，大概一看还是比较好理解的</p>
<p><img src="http://www.wangzhixian.org/wp-content/uploads/2016/10/8.png" alt=""></p>
<p>F5反编译出来的代码也已经比较合理</p>
<p><img src="http://www.wangzhixian.org/wp-content/uploads/2016/10/9.png" alt=""></p>
<p>接下来的分析其实看雪上面已经有大牛贴出来了</p>
<p><a href="http://bbs.pediy.com/showthread.php?t=207025" title="sherrydl---大神cm逆向题-解题步骤">http://bbs.pediy.com/showthread.php?t=207025</a></p>
<p>这里我也完整的写一下吧</p>
<p>完整的代码</p>
<pre><code>int __fastcall Java_by_Ericky_crackme01_JNI_EatRice(int a1, int a2, int a3, int a4)
{
  int v4; // r4@1
  signed int v5; // r6@1
  int v6; // r5@1
  char v7; // r3@4
  unsigned __int8 v8; // r2@4
  signed int v9; // r5@4
  signed int v10; // r7@4
  unsigned __int8 v11; // r6@9
  signed int v12; // r4@9
  signed int v13; // r5@9
  signed int v14; // r7@12
  unsigned __int8 v15; // r3@14
  signed int i; // r5@14
  unsigned int v17; // r6@16
  int v18; // r4@22
  signed int v19; // r7@22
  int v20; // r5@24
  unsigned int v21; // r4@24
  signed int v22; // r5@26
  signed int v23; // r0@27
  int v24; // r0@27
  signed int v26; // r4@33
  signed int v27; // r3@35
  int v28; // r3@37
  signed int v29; // r2@37
  char v30; // [sp+0h] [bp-28h]@22
  signed int v31; // [sp+4h] [bp-24h]@7
  int v32; // [sp+8h] [bp-20h]@4
  _BYTE *v33; // [sp+10h] [bp-18h]@4

  v4 = a4;
  v5 = 0;
  byte_4004 = 0;
  byte_4008 = 0;
  byte_400C = 0;
  byte_4010 = 0;
  v6 = sub_10C4(a1, a3);
  if ( *(_BYTE *)v6 != 88 || *(_BYTE *)(v6 + 1) != 35 || v4 != 7 )
  {
    j_j_sleep(3u);
    return 0;
  }
  v33 = j_j_malloc(1u);
  v7 = 35;
  *v33 = 35;
  v8 = *(_BYTE *)(v6 + 2);
  v32 = v6;
  v33[1] = v8;
  v9 = -1;
  v10 = 63689;
  while ( 1 )
  {
    v5 = (unsigned __int8)v7 + v5 * v10;
    if ( v9 == -2 )
      break;
    v10 *= 378551;
    v7 = v33[-v9--];
  }
  v31 = 1;
  if ( ((v5 + (v5 &gt;&gt; 31)) ^ (v5 &gt;&gt; 31)) == 2020122470 )
    byte_4004 = 1;
  *v33 = v8;
  v11 = *(_BYTE *)(v32 + 3);
  v33[1] = v11;
  v12 = -1;
  v13 = 1315423911;
  while ( 1 )
  {
    v13 ^= ((unsigned int)v13 &gt;&gt; 2) + 32 * v13 + v8;
    if ( v12 == -2 )
      break;
    v8 = v33[-v12--];
  }
  v14 = 0;
  if ( ((v13 + (v13 &gt;&gt; 31)) ^ (v13 &gt;&gt; 31)) == 1532463978 )
    byte_4008 = 1;
  *v33 = v11;
  v15 = *(_BYTE *)(v32 + 4);
  v33[1] = v15;
  for ( i = -1; ; --i )
  {
    v17 = v11 + 16 * v14;
    v14 = v17 &amp; 0xF0000000 ? ((v17 &amp; 0xF0000000) &gt;&gt; 24) ^ v17 &amp; 0xFFFFFFF : v17;
    if ( i == -2 )
      break;
    v11 = v33[-i];
  }
  if ( ((v14 + (v14 &gt;&gt; 31)) ^ (v14 &gt;&gt; 31)) == 728 )
    byte_400C = 1;
  *v33 = v15;
  v30 = *(_BYTE *)(v32 + 5);
  v33[1] = v30;
  v18 = 0;
  v19 = -1;
  while ( 1 )
  {
    v20 = v15 + v18;
    v21 = v15 + v18;
    if ( v20 &amp; 0xF0000000 )
      v21 = ((v20 &amp; 0xF0000000) &gt;&gt; 24) ^ v20;
    v22 = ((v20 | 0xFFFFFFF) ^ 0xF0000000) &amp; v21;
    if ( v19 == -2 )
      break;
    v15 = v33[-v19--];
    v18 = 16 * v21;
  }
  *v33 = v30;
  v33[1] = *(_BYTE *)(v32 + 6);
  v23 = sub_1238(v33, 2);
  v24 = (v23 + (v23 &gt;&gt; 31)) ^ (v23 &gt;&gt; 31);
  if ( ((v22 + (v22 &gt;&gt; 31)) ^ (v22 &gt;&gt; 31)) == 960 &amp;&amp; v24 == 789320428 )
  {
    byte_4010 = 1;
LABEL_32:
    v31 = 0;
    goto LABEL_33;
  }
  if ( byte_4010 )
    goto LABEL_32;
LABEL_33:
  v26 = 1;
  if ( byte_4008 )
    v26 = 0;
  v27 = 1;
  if ( byte_4004 )
    v27 = 0;
  v28 = v27 | v26;
  v29 = 1;
  if ( byte_400C )
    v29 = 0;
  return ~(v28 | v29 | v31) &amp; 1;
}
</code></pre><p>然后我们来处理一下结构体的识别还有命名等初始工作</p>
<p>导入JNI.h</p>
<p>修正第一个参数为JNIEnv*类型，修改第一个变量为env</p>
<p>该方法在Java层的定义，这个很有用，可以快速的进行参数类型修正</p>
<pre><code>public static native boolean EatRice(String arg0, int arg1) {
}
</code></pre><p>那么a3，a4的类型分别是jstring和jint，分别修正，并重新命名为regCode和regCodeLength</p>
<p>同时这是一个静态方法，第二个参数可以不用管</p>
<p>然后开始读代码，v4位注册码长度，然后四个变量初始化为0，接着调用sub_10C4()</p>
<pre><code>v4 = regCodeLength;
v5 = 0;
byte_4004 = 0;
byte_4008 = 0;
byte_400C = 0;
byte_4010 = 0;
v6 = sub_10C4(env, regCode);
</code></pre><p>双击进入sub_10C4()</p>
<pre><code>_BYTE *__fastcall sub_10C4(int a1, int a2)
{
  int v2; // ST08_4@1
  int v3; // r4@1
  int v4; // ST04_4@1
  int v5; // r7@1
  int v6; // r0@1
  int v7; // r5@1
  int v8; // r7@1
  _BYTE *v9; // r6@1
  int v11; // [sp+8h] [bp-18h]@1

  v2 = a2;
  v3 = a1;
  v4 = (*(int (**)(void))(*(_DWORD *)a1 + 24))();
  v5 = (*(int (__fastcall **)(int, const char *))(*(_DWORD *)v3 + 668))(v3, &quot;utf-8&quot;);
  v6 = (*(int (__fastcall **)(int, int, const char *, const char *))(*(_DWORD *)v3 + 132))(
         v3,
         v4,
         &quot;getBytes&quot;,
         &quot;(Ljava/lang/String;)[B&quot;);
  v7 = sub_12AC(v3, v2, v6, v5);
  v8 = (*(int (__fastcall **)(int, int))(*(_DWORD *)v3 + 684))(v3, v7);
  v9 = 0;
  v11 = (*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v3 + 736))(v3, v7, 0);
  if ( v8 &gt;= 1 )
  {
    v9 = j_j_malloc(v8 + 1);
    j_j___aeabi_memcpy();
    v9[v8] = 0;
  }
  (*(void (__fastcall **)(int, int, int, _DWORD))(*(_DWORD *)v3 + 768))(v3, v7, v11, 0);
  return v9;
}
</code></pre><p>来修正一下</p>
<p>第一个参数是JNIEnv*，第二个参数是jstring</p>
<p>修正完类型和重命名之后，可以看到有些函数识别出来了</p>
<pre><code>_BYTE *__fastcall sub_10C4(JNIEnv *env, jstring regCode)
{
  jstring vRegCode; // ST08_4@1
  JNIEnv *vEnv; // r4@1
  int v4; // ST04_4@1
  int v5; // r7@1
  int v6; // r0@1
  int v7; // r5@1
  int v8; // r7@1
  _BYTE *v9; // r6@1
  int v11; // [sp+8h] [bp-18h]@1

  vRegCode = regCode;
  vEnv = env;
  v4 = ((int (*)(void))(*env)-&gt;FindClass)();
  v5 = ((int (__fastcall *)(JNIEnv *, const char *))(*vEnv)-&gt;NewStringUTF)(vEnv, &quot;utf-8&quot;);
  v6 = ((int (__fastcall *)(JNIEnv *, int, const char *, const char *))(*vEnv)-&gt;GetMethodID)(
         vEnv,
         v4,
         &quot;getBytes&quot;,
         &quot;(Ljava/lang/String;)[B&quot;);
  v7 = sub_12AC(vEnv, vRegCode, v6, v5);
  v8 = ((int (__fastcall *)(JNIEnv *, int))(*vEnv)-&gt;GetArrayLength)(vEnv, v7);
  v9 = 0;
  v11 = ((int (__fastcall *)(JNIEnv *, int, _DWORD))(*vEnv)-&gt;GetByteArrayElements)(vEnv, v7, 0);
  if ( v8 &gt;= 1 )
  {
    v9 = j_j_malloc(v8 + 1);
    j_j___aeabi_memcpy();
    v9[v8] = 0;
  }
  ((void (__fastcall *)(JNIEnv *, int, int, _DWORD))(*vEnv)-&gt;ReleaseByteArrayElements)(vEnv, v7, v11, 0);
  return v9;
}
</code></pre><p>但是这时候看着还不是很爽</p>
<p>如下点击，每一个env函数都点击一遍</p>
<p><img src="http://www.wangzhixian.org/wp-content/uploads/2016/10/10.png" alt=""></p>
<p>结果如下，这下子看着爽多了</p>
<pre><code>_BYTE *__fastcall sub_10C4(JNIEnv *env, jstring regCode)
{
  jstring vRegCode; // ST08_4@1
  JNIEnv *vEnv; // r4@1
  jclass v4; // ST04_4@1
  jstring v5; // r7@1
  jmethodID v6; // r0@1
  void *v7; // r5@1
  jsize v8; // r7@1
  _BYTE *v9; // r6@1
  jbyte *v11; // [sp+8h] [bp-18h]@1

  vRegCode = regCode;
  vEnv = env;
  v4 = (*env)-&gt;FindClass(env, &quot;java/lang/String&quot;);
  v5 = (*vEnv)-&gt;NewStringUTF(vEnv, &quot;utf-8&quot;);
  v6 = (*vEnv)-&gt;GetMethodID(vEnv, v4, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;);
  v7 = (void *)sub_12AC(vEnv, vRegCode, v6, v5);
  v8 = (*vEnv)-&gt;GetArrayLength(vEnv, v7);
  v9 = 0;
  v11 = (*vEnv)-&gt;GetByteArrayElements(vEnv, v7, 0);
  if ( v8 &gt;= 1 )
  {
    v9 = j_j_malloc(v8 + 1);
    j_j___aeabi_memcpy();
    v9[v8] = 0;
  }
  (*vEnv)-&gt;ReleaseByteArrayElements(vEnv, v7, v11, 0);
  return v9;
}
</code></pre><p>代码也是比较简单，这三句比较关键</p>
<p>就是一个将Java的String类型的字符串转为byte类型，然后重新进行取值返回</p>
<pre><code>v5 = (*vEnv)-&gt;NewStringUTF(vEnv, &quot;utf-8&quot;);
v6 = (*vEnv)-&gt;GetMethodID(vEnv, v4, &quot;getBytes&quot;, &quot;(Ljava/lang/String;)[B&quot;);
v7 = (void *)sub_12AC(vEnv, vRegCode, v6, v5);
</code></pre><p>如果不熟悉的话呢，可以跟进sub_12AC()</p>
<p>可以看到就是一个调用函数的操作</p>
<pre><code>jobject __fastcall sub_12AC(JNIEnv *a1, int a2, int a3, int a4)
{
  int v5; // [sp+1Ch] [bp-4h]@1

  v5 = a4;
  return (*a1)-&gt;CallObjectMethodV(a1, (jobject)a2, (jmethodID)a3, (int **__attribute__((__org_typedef(va_list))) )&amp;v5);
}
</code></pre><p>那么现在我们可以回到最开始，这就是一个jstringtobyte的方法</p>
<p>修改一下返回的结果</p>
<pre><code>byte_regCode = jstringtobyte(env, regCode);
if ( *byte_regCode != 88 || byte_regCode[1] != 35 || v4 != 7 )
{
  j_j_sleep(3u);
  return 0;
}
</code></pre><p>可以看到前两位的判断写在了if里，一个是88，一个是35，但这要转换为字符</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

int main()
{
    int regCode[] = {88, 35};
    for(int i = 0; i &lt; sizeof(regCode) / 4; i++)
    {
        cout &lt;&lt; &quot;第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;位注册码 : &quot; &lt;&lt; (char)regCode[i] &lt;&lt; endl;
    }
    return 0;
}
</code></pre><p>运行一下得出</p>
<pre><code>第1位注册码 : X
第2位注册码 : #
</code></pre><p>并且还有一个条件，注册码长度是7，不满足直接返回失败</p>
<p>接下来第三位注册码赋值给v8，同时注册码首地址赋值给v32，也就是v32的值就是注册码数组的首地址，重命名一下，v33就当做一个临时变量好了</p>
<p>下面进入一个while(1)的循环，这个循环起始会执行两次，当第一次执行完的时候，v9自减1，第二次在if那里就会break</p>
<p>下面的if其实可以缩减一下，因为异或只有不同才会为1，两个相同的值异或就为0</p>
<pre><code>if ( v5 == 0x78689F66 )
</code></pre><p>二进制里面给eax寄存器清0也是很喜欢</p>
<pre><code>xor eax, eax
</code></pre><p>那么代码如下修正后的代码如下</p>
<pre><code>byte_regCode_new = j_j_malloc(1u);
v7 = 35;
*byte_regCode_new = 35;
v8 = byte_regCode[2];
byte_regCode_1 = byte_regCode;
byte_regCode_new[1] = v8;
v9 = -1;
v10 = 63689;
while ( 1 )
{
  v5 = (unsigned __int8)v7 + v5 * v10;
  if ( v9 == -2 )
    break;
  v10 *= 378551;
  v7 = byte_regCode_new[-v9--];
}
v31 = 1;
if ( ((v5 + (v5 &gt;&gt; 31)) ^ (v5 &gt;&gt; 31)) == 0x78689F66 )
  byte_4004 = 1;
</code></pre><p>计算第三位注册码的代码</p>
<pre><code>void funcregCode_3()
{
    for(int i = 0; i &lt;= 0xff; i++)
    {
        int v5 = 0;
        int v7 = 35;
        int v10 = 63689;
        v5 = v7 + v5 * v10;
        v10 *= 378551;
        v7 = i;
        v5 = v7 + v5 * v10;
        if ( v5 == 0x78689F66 )
        {
            cout &lt;&lt; &quot;第3位注册码 : &quot; &lt;&lt; (char)i &lt;&lt; endl;
            break;
        }
    }
}
</code></pre><p>根据上面的规律，第四位注册码的校验代码段如下</p>
<pre><code>*byte_regCode_new = v8;
v11 = byte_regCode_1[3];
byte_regCode_new[1] = v11;
v12 = -1;
v13 = 1315423911;
while ( 1 )
{
  v13 ^= ((unsigned int)v13 &gt;&gt; 2) + 32 * v13 + v8;
  if ( v12 == -2 )
    break;
  v8 = byte_regCode_new[-v12--];
}
v14 = 0;
if ( ((v13 + (v13 &gt;&gt; 31)) ^ (v13 &gt;&gt; 31)) == 0x5B578B6A )
  byte_4008 = 1;
</code></pre><p>按照上面的分析方法，我们可以写出计算第四位注册码的代码</p>
<pre><code>void funcregCode_4()
{
    for(unsigned int i = 0; i &lt; 128; i++)
    {
        int v12 = -1;
        signed int v13 = 0x4E67C6A7;
        unsigned int v8 = 121;
        while ( 1 )
        {
            v13 ^= ((unsigned int)v13 &gt;&gt; 2) + 32 * v13 + v8;
            if ( v12 == -2 )
                break;
            v8 = i;
            v12--;
        }
        if ( ((v13 + (v13 &gt;&gt; 31)) ^ (v13 &gt;&gt; 31)) == 0x5B578B6A )
        {
            cout &lt;&lt; &quot;第4位注册码 : &quot; &lt;&lt; (char)v8 &lt;&lt; &quot; &quot; &lt;&lt; v8 &lt;&lt; endl;
            break;
        }
    }
}
</code></pre><p>第五位注册码的校验代码</p>
<pre><code>*byte_regCode_new = v11;                     
v15 = byte_regCode_1[4];
byte_regCode_new[1] = v15;                  
for ( i = -1; ; --i )
{
  v17 = v11 + 16 * v14;
  v14 = v17 &amp; 0xF0000000 ? ((v17 &amp; 0xF0000000) &gt;&gt; 24) ^ v17 &amp; 0xFFFFFFF : v17;
  if ( i == -2 )
    break;
  v11 = byte_regCode_new[-i];
}
if ( ((v14 + (v14 &gt;&gt; 31)) ^ (v14 &gt;&gt; 31)) == 0x2D8 )
  byte_400C = 1;
</code></pre><p>计算第五位注册码</p>
<pre><code>void funcregCode_5()
{
    for(unsigned int i = 0; i &lt; 128; i++)
    {
        signed int v14 = 0;
        unsigned int v17;
        unsigned int v11 = 42;
        for (unsigned int j = -1; ; --j )
        {
            v17 = v11 + 16 * v14;
            v14 = v17 &amp; 0xF0000000 ? ((v17 &amp; 0xF0000000) &gt;&gt; 24) ^ v17 &amp; 0xFFFFFFF : v17;
            if ( j == -2 )
                break;
            v11 = i;
        }
        if ( ((v14 + (v14 &gt;&gt; 31)) ^ (v14 &gt;&gt; 31)) == 0x2D8 )
        {
            cout &lt;&lt; &quot;第5位注册码 : &quot; &lt;&lt; (char)i &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;
            break;
        }
    }
}
</code></pre><p>接下来第六位和第七位注册码混在了一起</p>
<pre><code>v18 = 0;
v19 = -1;
while ( 1 )
{
  v20 = v15 + v18;
  v21 = v15 + v18;
  if ( v20 &amp; 0xF0000000 )
    v21 = ((v20 &amp; 0xF0000000) &gt;&gt; 24) ^ v20;
  v22 = ((v20 | 0xFFFFFFF) ^ 0xF0000000) &amp; v21;
  if ( v19 == -2 )
    break;
  v15 = byte_regCode_new[-v19--];
  v18 = 16 * v21;
}
*byte_regCode_new = v30;                      // regCode_new[0]是第6位注册码
byte_regCode_new[1] = byte_regCode_1[6];      // regCode_new[1]是第7位注册码
v23 = sub_1238(byte_regCode_new, 2);
v24 = (v23 + (v23 &gt;&gt; 31)) ^ (v23 &gt;&gt; 31);
if ( ((v22 + (v22 &gt;&gt; 31)) ^ (v22 &gt;&gt; 31)) == 0x3C0 &amp;&amp; v24 == 0x2F0C12EC )
</code></pre><p>可以看到最后if有两个条件判断，第一个v22参数由前面while(1)里校验第六位注册码的代码决定，第二个v24参数由后面校验第七位注册码的代码决定</p>
<p>校验第六位注册码的代码拆分出来</p>
<pre><code>v18 = 0;
v19 = -1;
while ( 1 )
{
  v20 = v15 + v18;
  v21 = v15 + v18;
  if ( v20 &amp; 0xF0000000 )
    v21 = ((v20 &amp; 0xF0000000) &gt;&gt; 24) ^ v20;
  v22 = ((v20 | 0xFFFFFFF) ^ 0xF0000000) &amp; v21;
  if ( v19 == -2 )
    break;
  v15 = byte_regCode_new[-v19--];
  v18 = 16 * v21;
}
if ( ((v22 + (v22 &gt;&gt; 31)) ^ (v22 &gt;&gt; 31)) == 0x3C0 )
</code></pre><p>那么现在就可以写出计算第六位注册码的代码</p>
<pre><code>void funcregCode_6()
{
    signed int v22;
    for(unsigned int i = 0; i &lt; 128; i++)
    {
        int v18 = 0;
        signed int v19 = -1;
        unsigned int v15 = 56;
        while ( 1 )
        {
            int v20 = v15 + v18;
            unsigned int v21 = v15 + v18;
            if ( v20 &amp; 0xF0000000 )
                v21 = ((v20 &amp; 0xF0000000) &gt;&gt; 24) ^ v20;
            v22 = ((v20 | 0xFFFFFFF) ^ 0xF0000000) &amp; v21;
            if ( v19 == -2 )
                break;
            v15 = i;
            v18 = 16 * v21;
            v19--;
        }
        if ( ((v22 + (v22 &gt;&gt; 31)) ^ (v22 &gt;&gt; 31)) == 0x3C0 )
        {
            cout &lt;&lt; &quot;第6位注册码 : &quot; &lt;&lt; (char)i &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;
            break;
        }
    }
}
</code></pre><p>第七位注册码的校验在另一个函数sub_1238里</p>
<pre><code>*byte_regCode_new = v30;                      // regCode_new[0]是第6位注册码
byte_regCode_new[1] = byte_regCode_1[6];      // regCode_new[1]是第7位注册码
v23 = sub_1238(byte_regCode_new, 2);
v24 = (v23 + (v23 &gt;&gt; 31)) ^ (v23 &gt;&gt; 31);
if ( v24 == 0x2F0C12EC )
</code></pre><p>跟入sub_1238，也是比较简单的，第六位和第七位注册码进行一个计算</p>
<pre><code>int __fastcall sub_1238(_BYTE *a1, int a2)
{
  int v2; // r7@1
  int v3; // r3@1
  int v4; // r4@1
  int v5; // r2@1
  unsigned int v6; // r6@2

  v2 = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  while ( a2 )
  {
    v6 = *a1;
    v4 += (v6 &gt;&gt; 2) * v4 * v6 + 804604770;
    v2 += 32 * v6 * v2 * v6 + 1491913760;
    v3 = v3 + 8 * v6 * v3 * v6 - 1774596542;
    v5 = v5 + 2 * v6 * v5 * v6 - 1263339326;
    --a2;
    ++a1;
  }
  return v4 + v5 + v3 + v2;
}
</code></pre><p>那么计算第七位注册码的代码</p>
<pre><code>void funcregCode_7()
{
    int a2, v2, v3, v4, v5;
    int v23, v24;
    unsigned int v6;
    for(unsigned int i = 0; i &lt; 128; i++)
    {
        v2 = 0;
        v3 = 0;
        v4 = 0;
        v5 = 0;
        a2 = 2;

        v6 = 64;
        v4 += (v6 &gt;&gt; 2) * v4 * v6 + 804604770;
        v2 += 32 * v6 * v2 * v6 + 1491913760;
        v3 = v3 + 8 * v6 * v3 * v6 - 1774596542;
        v5 = v5 + 2 * v6 * v5 * v6 - 1263339326;

        v6 = i;
        v4 += (v6 &gt;&gt; 2) * v4 * v6 + 804604770;
        v2 += 32 * v6 * v2 * v6 + 1491913760;
        v3 = v3 + 8 * v6 * v3 * v6 - 1774596542;
        v5 = v5 + 2 * v6 * v5 * v6 - 1263339326;

        v23 = v4 + v5 + v3 + v2;
        v24 = (v23 + (v23 &gt;&gt; 31)) ^ (v23 &gt;&gt; 31);
        if ( v24 == 0x2F0C12EC )
        {
            cout &lt;&lt; &quot;第7位注册码 : &quot; &lt;&lt; (char)i &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;
            break;
        }
    }
}
</code></pre><p>整个代码运行一下的结果</p>
<pre><code>第1位注册码 : X 88
第2位注册码 : # 35
第3位注册码 : y 121
第4位注册码 : * 42
第5位注册码 : 8 56
第6位注册码 : @ 64
第7位注册码 : L 76
</code></pre><p>如果是刚开始接触so逆向的同学呢，仔细分析一下这个样本，相信收获还是蛮大的</p>
<p>那么完整的计算注册码的代码</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

void funcregCode_3();
void funcregCode_4();
void funcregCode_5();
void funcregCode_6();
void funcregCode_7();

int main()
{
    int regCode[] = {88, 35};
    for(int i = 0; i &lt; sizeof(regCode) / 4; i++)
    {
        cout &lt;&lt; &quot;第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;位注册码 : &quot; &lt;&lt; (char)regCode[i] &lt;&lt; &quot; &quot; &lt;&lt; regCode[i] &lt;&lt; endl;
    }
    funcregCode_3();
    funcregCode_4();
    funcregCode_5();
    funcregCode_6();
    funcregCode_7();
    return 0;
}

void funcregCode_3()
{
    for(int i = 0; i &lt;= 0xff; i++)
    {
        int v5 = 0;
        int v7 = 35;
        int v10 = 63689;
        v5 = v7 + v5 * v10;
        v10 *= 378551;
        v7 = i;
        v5 = v7 + v5 * v10;
        if ( v5 == 0x78689F66 )
        {
            cout &lt;&lt; &quot;第3位注册码 : &quot; &lt;&lt; (char)i &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;
            break;
        }
    }
}

void funcregCode_4()
{
    for(unsigned int i = 0; i &lt; 128; i++)
    {
        int v12 = -1;
        signed int v13 = 0x4E67C6A7;
        unsigned int v8 = 121;
        while ( 1 )
        {
            v13 ^= ((unsigned int)v13 &gt;&gt; 2) + 32 * v13 + v8;
            if ( v12 == -2 )
                break;
            v8 = i;
            v12--;
        }
        if ( ((v13 + (v13 &gt;&gt; 31)) ^ (v13 &gt;&gt; 31)) == 0x5B578B6A )
        {
            cout &lt;&lt; &quot;第4位注册码 : &quot; &lt;&lt; (char)v8 &lt;&lt; &quot; &quot; &lt;&lt; v8 &lt;&lt; endl;
            break;
        }
    }
}

void funcregCode_5()
{
    for(unsigned int i = 0; i &lt; 128; i++)
    {
        signed int v14 = 0;
        unsigned int v17;
        unsigned int v11 = 42;
        for (unsigned int j = -1; ; --j )
        {
            v17 = v11 + 16 * v14;
            v14 = v17 &amp; 0xF0000000 ? ((v17 &amp; 0xF0000000) &gt;&gt; 24) ^ v17 &amp; 0xFFFFFFF : v17;
            if ( j == -2 )
                break;
            v11 = i;
        }
        if ( ((v14 + (v14 &gt;&gt; 31)) ^ (v14 &gt;&gt; 31)) == 0x2D8 )
        {
            cout &lt;&lt; &quot;第5位注册码 : &quot; &lt;&lt; (char)i &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;
            break;
        }
    }
}

void funcregCode_6()
{
    signed int v22;
    for(unsigned int i = 0; i &lt; 128; i++)
    {
        int v18 = 0;
        signed int v19 = -1;
        unsigned int v15 = 56;
        while ( 1 )
        {
            int v20 = v15 + v18;
            unsigned int v21 = v15 + v18;
            if ( v20 &amp; 0xF0000000 )
                v21 = ((v20 &amp; 0xF0000000) &gt;&gt; 24) ^ v20;
            v22 = ((v20 | 0xFFFFFFF) ^ 0xF0000000) &amp; v21;
            if ( v19 == -2 )
                break;
            v15 = i;
            v18 = 16 * v21;
            v19--;
        }
        if ( ((v22 + (v22 &gt;&gt; 31)) ^ (v22 &gt;&gt; 31)) == 0x3C0 )
        {
            cout &lt;&lt; &quot;第6位注册码 : &quot; &lt;&lt; (char)i &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;
            break;
        }
    }
}

void funcregCode_7()
{
    int a2, v2, v3, v4, v5;
    int v23, v24;
    unsigned int v6;
    for(unsigned int i = 0; i &lt; 128; i++)
    {
        v2 = 0;
        v3 = 0;
        v4 = 0;
        v5 = 0;
        a2 = 2;

        v6 = 64;
        v4 += (v6 &gt;&gt; 2) * v4 * v6 + 804604770;
        v2 += 32 * v6 * v2 * v6 + 1491913760;
        v3 = v3 + 8 * v6 * v3 * v6 - 1774596542;
        v5 = v5 + 2 * v6 * v5 * v6 - 1263339326;

        v6 = i;
        v4 += (v6 &gt;&gt; 2) * v4 * v6 + 804604770;
        v2 += 32 * v6 * v2 * v6 + 1491913760;
        v3 = v3 + 8 * v6 * v3 * v6 - 1774596542;
        v5 = v5 + 2 * v6 * v5 * v6 - 1263339326;

        v23 = v4 + v5 + v3 + v2;
        v24 = (v23 + (v23 &gt;&gt; 31)) ^ (v23 &gt;&gt; 31);
        if ( v24 == 0x2F0C12EC )
        {
            cout &lt;&lt; &quot;第7位注册码 : &quot; &lt;&lt; (char)i &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; endl;
            break;
        }
    }
}
</code></pre><p>边分析边写代码，大伙凑合的看就好(　ﾟ∀ﾟ) ﾉ♡</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
