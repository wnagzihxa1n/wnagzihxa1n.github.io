<!DOCTYPE html>
<html>
<head>
<title>use-NDK-to-build-an-APK</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="use-ndk-to-build-an-apk">Use NDK to build an APK</h1>
<p><strong>Author：wnagzihxain<br>Mail：tudouboom@163.com</strong></p>
<h2 id="0x00-">0x00 前言</h2>
<p>每个人都有自己的学习方法，我学习ARM汇编的方法就是先正向编程，然后用IDA逆向，对照着源码一句一句读，总结出经验，这一系列so逆向的分享适合有Java层逆向经验，会使用Android Studio开发，会C/C++，Java编程，但是不会so逆向或者说没有接触过so逆向同时准备学习so逆向的同学，不需要掌握很深入，常用的语法以及用法知道就行，不常用或者说看到某种语法，虽然自己不知道什么意思，但是可以自己通过搜索引擎搜索相关的知识学习掌握，有这种能力就行</p>
<h2 id="0x01-">0x01 编译</h2>
<p>C和C++，一个面向过程，一个面向对象，都可以用于NDK开发，但是它们有什么区别呢？</p>
<p>这要在源码中寻找答案了</p>
<p>我们先来编译一个包含so的APK，很多教程都喜欢&quot;Hello JNI&quot;，那么我们这里也来一个</p>
<p>使用Android Studio创建Android工程，SDK版本4.4</p>
<p>声明调用的so文件，并定义一个静态native函数<code>getStringFromNative()</code></p>
<p>MainActivity.java</p>
<pre><code>package com.wnagzihxain.myapplication;

import android.app.Activity;
import android.os.Bundle;
import android.widget.Toast;

public class MainActivity extends Activity {

    static {
        System.loadLibrary(&quot;totoc&quot;);
    }

    public native static String getStringFromNative();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Toast.makeText(this, getStringFromNative(), Toast.LENGTH_LONG).show();
    }
}
</code></pre><p>执行<code>Make Project</code>    </p>
<pre><code>Build -&gt; Make Project
</code></pre><p>接着可以在<code>app/build/intermediates/classes/debug</code>下面看到生成的class文件</p>
<p><img src="Image/1.png" alt=""></p>
<p>然后在<code>app/src/main/java</code>下面执行</p>
<pre><code>C:\Users\wangz\Desktop\MyApplication\app\src\main\java&gt;javah com.wnagzihxain.myapplication.MainActivity
</code></pre><p>生成一个头文件</p>
<pre><code>com_wnagzihxain_myapplication_MainActivity.h
</code></pre><p><img src="Image/2.png" alt=""></p>
<p>我们修改一下头文件名为<code>totoc.h</code></p>
<p>在<code>app/src/main</code>下新建<code>jni</code>文件夹，跟<code>java</code>同目录</p>
<p>将刚刚生成的头文件移动到<code>jni</code>下面</p>
<h3 id="1-1-c-hello-jni">1.1 C++版本的Hello JNI</h3>
<p>新建<code>C++ Source</code>文件<code>totoc.cpp</code></p>
<p>将头文件中生成的函数信息复制进去，修改参数并添加返回语句</p>
<pre><code>//
// Created by wnagzihxain on 2016/12/17 0017.
//

#include &lt;iostream&gt;
#include &lt;jni.h&gt;
#include &quot;totoc.h&quot;

using namespace std;

/*
 * Class:     com_wnagzihxain_myapplication_MainActivity
 * Method:    getStringFromNative
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_wnagzihxain_myapplication_MainActivity_getStringFromNative(JNIEnv *env, jclass clazz)
{
    return env-&gt;NewStringUTF(&quot;Hello From JNI!&quot;);
}
</code></pre><p>关于函数定义前面的<code>JNIEXPORT</code>和<code>JNICALL</code>是什么意思，可参考下面这个</p>
<pre><code>#define JNIEXPORT __declspec(dllexport)
#define JNIIMPORT __declspec(dllimport)
#define JNICALL __stdcall
</code></pre><p>修改<code>build.gradle</code></p>
<p>默认的配置如下：</p>
<pre><code>apply plugin: &#39;com.android.application&#39;

android {
    compileSdkVersion 25
    buildToolsVersion &quot;25.0.1&quot;
    defaultConfig {
        applicationId &quot;com.wnagzihxain.myapplication&quot;
        minSdkVersion 19
        targetSdkVersion 25
        versionCode 1
        versionName &quot;1.0&quot;
        testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }
}

dependencies {
    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
    androidTestCompile(&#39;com.android.support.test.espresso:espresso-core:2.2.2&#39;, {
        exclude group: &#39;com.android.support&#39;, module: &#39;support-annotations&#39;
    })
    compile &#39;com.android.support:appcompat-v7:25.0.1&#39;
    testCompile &#39;junit:junit:4.12&#39;
}
</code></pre><p>改一下：</p>
<pre><code>apply plugin: &#39;com.android.model.application&#39;

model {
    android {
        compileSdkVersion 25
        buildToolsVersion &quot;25.0.1&quot;
        defaultConfig {
            applicationId &quot;com.wnagzihxain.myapplication&quot;
            minSdkVersion.apiLevel 19
            targetSdkVersion.apiLevel 25
            versionCode 1
            versionName &quot;1.0&quot;
            testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot;
        }
        buildTypes {
            release {
                minifyEnabled false
                proguardFiles.add(file(&quot;proguard-rules.pro&quot;))
            }
        }
        ndk {
            moduleName &quot;totoc&quot;
            stl &quot;stlport_static&quot;
            ldLibs.addAll([&quot;log&quot;, &quot;z&quot;, &quot;android&quot;])
            abiFilters.addAll([&#39;armeabi&#39;, &#39;armeabi-v7a&#39;])
        }
    }
}


dependencies {
    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])
    androidTestCompile(&#39;com.android.support.test.espresso:espresso-core:2.2.2&#39;, {
        exclude group: &#39;com.android.support&#39;, module: &#39;support-annotations&#39;
    })
    compile &#39;com.android.support:appcompat-v7:25.0.1&#39;
    testCompile &#39;junit:junit:4.12&#39;
}
</code></pre><p>讲解一下参数：</p>
<pre><code>moduleName &quot;totoc&quot;//so的名字
stl &quot;stlport_static&quot;//以静态链接方式使用的stlport版本的STL
ldLibs.addAll([&quot;log&quot;, &quot;z&quot;, &quot;android&quot;])
abiFilters.addAll([&#39;armeabi&#39;, &#39;armeabi-v7a&#39;])
</code></pre><p>关于NDK编译的配置我在这里推荐几篇文章，虽然是<code>mk</code>，但是参数的解释大概是一样的</p>
<p>网易云捕的博客：<a href="http://crash.163.com/#news/!newsId=24">Android NDK编译选项设置</a></p>
<p>CSDN-oZuiJiaoWeiYang的专栏：<a href="http://blog.csdn.net/ozuijiaoweiyang/article/details/50845899">eclipse as android jni 和 ndk以及调用过程--tread</a></p>
<p>修改项目的<code>build.gradle</code></p>
<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle:2.2.3&#39;

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre><p>改为</p>
<pre><code>// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath &#39;com.android.tools.build:gradle-experimental:0.8.3&#39;

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        jcenter()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}
</code></pre><p>改完后<code>Sync</code></p>
<p>等待构建完成我们就可以编译签名我们的APK了</p>
<p>一段漫长的等待后，APK编译签名好了</p>
<p>运行起来，弹出了Toast</p>
<h3 id="1-2-c-hello-jni">1.2 C版本的Hello JNI</h3>
<p>所有步骤和C++版本一样，有区别的两处是</p>
<p>新建<code>C++ Source</code>文件<code>totoc.cpp</code>改为新建<code>C Source</code>文件<code>totoc.c</code></p>
<p><code>totoc.c</code>文件内容修改为如下</p>
<pre><code>//
// Created by wnagzihxain on 2016/12/17 0017.
//

#include &lt;jni.h&gt;
#include &quot;totoc.h&quot;


/*
 * Class:     com_wnagzihxain_myapplication_MainActivity
 * Method:    getStringFromNative
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_wnagzihxain_myapplication_MainActivity_getStringFromNative(JNIEnv *env, jclass clazz)
{
    return (*env)-&gt;NewStringUTF(env, &quot;Hello From JNI!&quot;);
}
</code></pre><p>然后编译就行</p>
<h2 id="0x02-c-c-">0x02 C和C++使用的区别</h2>
<p>JNI：Java Native Interface，类似一种标准，提供了很多的API，使Java可以和C/C++进行通信</p>
<p>NDK：Native Development Kit，这是一套工具或者说是一套组件，实现用C/C++来开发Android Application</p>
<p>首先大概看一下代码，头文件的引入很好理解没有问题，然后是定义原生方法，来看原生方法的命名：</p>
<pre><code>Java_com_wnagzihxain_myapplication_MainActivity_getStringFromNative
</code></pre><p>Java_：前缀<br>com_wnagzihxain_myapplication_MainActivity：完整的类路径<br>getStringFromNative：Java层中定义的方法名</p>
<p>完整的定义方式：</p>
<pre><code>JNIEXPORT jstring JNICALL Java_com_wnagzihxain_myapplication_MainActivity_getStringFromNative(JNIEnv* env, jclass clazz)
</code></pre><p>我们记得在Java层中，并没有传递参数进来，只是纯粹的调用了这个原生方法，但是这里有两个参数，好了，这里就是很重要的一处关于C和C++在NDK开发中不一样的地方，第一个参数是env，如果使用C开发，这里的env其实是一个二级指针，最终指向JNINativeInterface的结构，有疑惑对吧，来看JNI.h中对这个结构的定义</p>
<pre><code>typedef const struct JNINativeInterface* JNIEnv;
</code></pre><p>所以结合上面的原生方法定义形式，相当于</p>
<pre><code>const struct JNINativeInterface** env;
</code></pre><p>顺便补充看一下这个结构体的定义，方法非常多，后面省略了</p>
<pre><code>struct JNINativeInterface {
    void*       reserved0;
    void*       reserved1;
    void*       reserved2;
    void*       reserved3;

    jint        (*GetVersion)(JNIEnv *);

    jclass      (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*,
                        jsize);
    jclass      (*FindClass)(JNIEnv*, const char*);

    jmethodID   (*FromReflectedMethod)(JNIEnv*, jobject);
    jfieldID    (*FromReflectedField)(JNIEnv*, jobject);
    /* spec doesn&#39;t show jboolean parameter */
    jobject     (*ToReflectedMethod)(JNIEnv*, jclass, jmethodID, jboolean);

    jclass      (*GetSuperclass)(JNIEnv*, jclass);
    jboolean    (*IsAssignableFrom)(JNIEnv*, jclass, jclass);

    ......
};
</code></pre><p>如果使用C++来开发的话，同样，先来看定义</p>
<pre><code>typedef _JNIEnv JNIEnv;
</code></pre><p>那么这时的env就是一个一级指针了，定义相当于</p>
<pre><code>struct _JNIEnv* env;
</code></pre><p>在JNI.h中的定义，省略了一点</p>
<pre><code>struct _JNIEnv {
    /* do not rename this; it does not seem to be entirely opaque */
    const struct JNINativeInterface* functions;

#if defined(__cplusplus)

    jint GetVersion()
    { return functions-&gt;GetVersion(this); }

    jclass DefineClass(const char *name, jobject loader, const jbyte* buf,
        jsize bufLen)
    { return functions-&gt;DefineClass(this, name, loader, buf, bufLen); }

    jclass FindClass(const char* name)
    { return functions-&gt;FindClass(this, name); }

    ......
#endif /*__cplusplus*/
};
</code></pre><p>那么在对比完两种语言开发下的env的差别后，大家对它应该是有一个大概的认识了，同时我们可以注意一下_JNIEnv结构体，里面有一句</p>
<pre><code>const struct JNINativeInterface* functions;
</code></pre><p>再结合结构体里的代码可以看出来这个结构体里的方法实现也是通过functions指针对JNINativeInterface结构体里的方法进行调用，也就是说无论是C还是C++，最后都调用了JNINativeInterface结构体里的方法，如果不考虑详细调用形式的话，那么大概就是上面这个情况</p>
<p>再来对比一下具体的代码：</p>
<pre><code>return (*env)-&gt;NewStringUTF(env, &quot;Hello From JNI!&quot;);        //C
return env-&gt;NewStringUTF(&quot;Hello From JNI!&quot;);                //C++
</code></pre><p>第一个参数就讲到这里，然后来看第二个参数，在Java中，有实例方法和静态方法，两种都可以在Java层通过添加native关键字来声明</p>
<p>Java层：</p>
<pre><code>public native String getStringFromNative();                //实例方法
public native static String getStringFromNative();         //静态方法
</code></pre><p>native层：</p>
<pre><code>//实例方法
JNIEXPORT jstring JNICALL Java_com_wnagzihxain_myapplication_MainActivity_getStringFromNative(JNIEnv* env, jobject thiz)

//静态方法
JNIEXPORT jstring JNICALL Java_com_wnagzihxain_myapplication_MainActivity_getStringFromNative(JNIEnv* env, jclass clazz)
</code></pre><p>可以看出来实例方法和静态方法的第二个参数不一样，实例方法是jobject类型，而静态方法是jclass类型，是这样的，如果是实例方法，那么必然是通过获取实例进行引用，而静态方法则没有实例，只能通过类引用</p>
<p>回到开头，还记不记得我们说在调用getStringFromNative()的时候，并没有进行参数传递，但是在native里却有两个参数env和thiz这个问题，这个点非常重要，因为在IDA反编译so的时候，并不会识别的非常准确，需要我们去修复，靠的就是这些小Tips</p>
<p>最后来看数据类型，还是在JNI.h里面</p>
<p>还是很好理解的，简单看一下就好</p>
<pre><code>#ifdef HAVE_INTTYPES_H
# include &lt;inttypes.h&gt;      /* C99 */
typedef uint8_t         jboolean;       /* unsigned 8 bits */
typedef int8_t          jbyte;          /* signed 8 bits */
typedef uint16_t        jchar;          /* unsigned 16 bits */
typedef int16_t         jshort;         /* signed 16 bits */
typedef int32_t         jint;           /* signed 32 bits */
typedef int64_t         jlong;          /* signed 64 bits */
typedef float           jfloat;         /* 32-bit IEEE 754 */
typedef double          jdouble;        /* 64-bit IEEE 754 */
#else
typedef unsigned char   jboolean;       /* unsigned 8 bits */
typedef signed char     jbyte;          /* signed 8 bits */
typedef unsigned short  jchar;          /* unsigned 16 bits */
typedef short           jshort;         /* signed 16 bits */
typedef int             jint;           /* signed 32 bits */
typedef long long       jlong;          /* signed 64 bits */
typedef float           jfloat;         /* 32-bit IEEE 754 */
typedef double          jdouble;        /* 64-bit IEEE 754 */
#endif
</code></pre><p>然后是数组类型，区分了C和C++</p>
<pre><code>#ifdef __cplusplus
/*
 * Reference types, in C++
 */
class _jobject {};
class _jclass : public _jobject {};
class _jstring : public _jobject {};
class _jarray : public _jobject {};
class _jobjectArray : public _jarray {};
class _jbooleanArray : public _jarray {};
class _jbyteArray : public _jarray {};
class _jcharArray : public _jarray {};
class _jshortArray : public _jarray {};
class _jintArray : public _jarray {};
class _jlongArray : public _jarray {};
class _jfloatArray : public _jarray {};
class _jdoubleArray : public _jarray {};
class _jthrowable : public _jobject {};

typedef _jobject*       jobject;
typedef _jclass*        jclass;
typedef _jstring*       jstring;
typedef _jarray*        jarray;
typedef _jobjectArray*  jobjectArray;
typedef _jbooleanArray* jbooleanArray;
typedef _jbyteArray*    jbyteArray;
typedef _jcharArray*    jcharArray;
typedef _jshortArray*   jshortArray;
typedef _jintArray*     jintArray;
typedef _jlongArray*    jlongArray;
typedef _jfloatArray*   jfloatArray;
typedef _jdoubleArray*  jdoubleArray;
typedef _jthrowable*    jthrowable;
typedef _jobject*       jweak;


#else /* not __cplusplus */

/*
 * Reference types, in C.
 */
typedef void*           jobject;
typedef jobject         jclass;
typedef jobject         jstring;
typedef jobject         jarray;
typedef jarray          jobjectArray;
typedef jarray          jbooleanArray;
typedef jarray          jbyteArray;
typedef jarray          jcharArray;
typedef jarray          jshortArray;
typedef jarray          jintArray;
typedef jarray          jlongArray;
typedef jarray          jfloatArray;
typedef jarray          jdoubleArray;
typedef jobject         jthrowable;
typedef jobject         jweak;

#endif /* not __cplusplus */
</code></pre><h2 id="0x03-">0x03 小结</h2>
<p>如果在编译过程遇到问题，一定要自己搜索解决，编译这一关很重要</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
